{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///main.js","webpack:///webpack/bootstrap beff17714b3976b8bb9b","webpack:///external {\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"_\",\"root\":\"_\"}","webpack:///./node_modules/pathfinding/src/core/DiagonalMovement.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack:///./src/widgets/BaseWidget.tsx","webpack:///./node_modules/pathfinding/src/core/Util.js","webpack:///./src/models/BaseModel.ts","webpack:///./src/Toolkit.ts","webpack:///./src/models/PointModel.ts","webpack:///./node_modules/pathfinding/src/core/Heuristic.js","webpack:///./src/models/NodeModel.ts","webpack:///./src/AbstractFactory.ts","webpack:///./src/models/PortModel.ts","webpack:///./src/BaseEntity.ts","webpack:///./node_modules/heap/index.js","webpack:///./node_modules/pathfinding/src/finders/JumpPointFinderBase.js","webpack:///./src/defaults/models/DefaultPortModel.ts","webpack:///./src/routing/PathFinding.ts","webpack:///./node_modules/pathfinding/src/core/Node.js","webpack:///./node_modules/pathfinding/src/finders/AStarFinder.js","webpack:///./node_modules/pathfinding/src/finders/BiAStarFinder.js","webpack:///./src/defaults/models/DefaultLinkModel.ts","webpack:///./src/models/LinkModel.ts","webpack:///./src/models/DiagramModel.ts","webpack:///./src/main.ts","webpack:///./src/defaults/models/DefaultNodeModel.ts","webpack:///./src/defaults/models/DefaultLabelModel.tsx","webpack:///./src/models/LabelModel.ts","webpack:///./src/defaults/widgets/DefaultLinkWidget.tsx","webpack:///./src/defaults/widgets/DefaultNodeWidget.tsx","webpack:///./src/defaults/widgets/DefaultPortLabelWidget.tsx","webpack:///./src/widgets/PortWidget.tsx","webpack:///./src/defaults/factories/DefaultPortFactory.tsx","webpack:///./src/CanvasActions.ts","webpack:///./src/widgets/layers/LinkLayerWidget.tsx","webpack:///./src/widgets/LinkWidget.tsx","webpack:///./src/widgets/layers/NodeLayerWidget.tsx","webpack:///./src/widgets/NodeWidget.tsx","webpack:///./node_modules/closest/index.js","webpack:///./node_modules/matches-selector/index.js","webpack:///./node_modules/pathfinding/index.js","webpack:///./node_modules/pathfinding/src/PathFinding.js","webpack:///./node_modules/heap/lib/heap.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/pathfinding/src/core/Grid.js","webpack:///./node_modules/pathfinding/src/finders/BestFirstFinder.js","webpack:///./node_modules/pathfinding/src/finders/BreadthFirstFinder.js","webpack:///./node_modules/pathfinding/src/finders/DijkstraFinder.js","webpack:///./node_modules/pathfinding/src/finders/BiBestFirstFinder.js","webpack:///./node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js","webpack:///./node_modules/pathfinding/src/finders/BiDijkstraFinder.js","webpack:///./node_modules/pathfinding/src/finders/IDAStarFinder.js","webpack:///./node_modules/pathfinding/src/finders/JumpPointFinder.js","webpack:///./node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js","webpack:///./node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js","webpack:///./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js","webpack:///./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js","webpack:///./node_modules/paths-js/path.js","webpack:///./src/defaults/factories/DefaultLinkFactory.tsx","webpack:///./src/defaults/factories/DefaultNodeFactory.ts","webpack:///./src/DiagramEngine.ts","webpack:///./src/defaults/factories/DefaultLabelFactory.tsx","webpack:///./src/defaults/widgets/DefaultLabelWidget.tsx","webpack:///./src/widgets/DiagramWidget.tsx"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","DiagonalMovement","Always","Never","IfAtMostOneObstacle","OnlyWhenNoObstacles","__extends","extendStatics","setPrototypeOf","__proto__","Array","b","__","constructor","create","__assign","assign","t","arguments","length","value","React","BaseWidget","_super","props","_this","className","bem","selector","baseClass","getClassName","getProps","extraProps","Component","backtrace","node","path","x","y","parent","push","reverse","biBacktrace","nodeA","nodeB","pathA","pathB","concat","pathLength","a","dx","dy","sum","Math","sqrt","interpolate","x0","y0","x1","y1","sx","sy","err","e2","abs","line","expandPath","coord0","coord1","interpolated","interpolatedLen","j","expanded","len","smoothenPath","grid","ex","ey","newPath","coord","testCoord","blocked","isWalkableAt","lastValidCoord","compressPath","lx","ly","ldx","ldy","sq","compressed","px","py","BaseEntity_1","_","BaseModel","type","id","selected","getParent","setParent","getSelectedEntities","isSelected","deSerialize","ob","engine","serialize","merge","getType","getID","setSelected","iterateListeners","listener","event","selectionChanged","remove","entityRemoved","BaseEntity","closest","PathFinding_1","Path","Toolkit","UID","TESTING","TESTING_UID","replace","r","random","toString","element","document","body","generateLinePath","firstPoint","lastPoint","generateCurvePath","curvy","generateDynamicPath","pathCoords","moveto","ROUTING_SCALING_FACTOR","slice","forEach","coords","lineto","print","BaseModel_1","PointModel","link","points","isConnectedToPort","getPortForPoint","getLink","removePoint","updateLocation","getX","getY","isLocked","manhattan","euclidean","octile","F","SQRT2","chebyshev","max","NodeModel","nodeType","extras","ports","setPosition","oldX","oldY","this_1","port","getLinks","point","getPointForPort","entities","this_2","portName","map","portOb","getPortFactory","getNewInstance","addPort","doClone","lookupTable","clone","values","getPortFromID","getPort","getPorts","removePort","updateDimensions","_a","width","height","AbstractFactory","NodeFactory","apply","LinkFactory","LabelFactory","PortFactory","SimplePortFactory","cb","initialConfig","PortModel","maximumLinks","links","parentNode","getNode","getName","getMaximumLinks","setMaximumLinks","removeLink","addLink","createLinkModel","isFinite","numberOfLinks","size","updateCoords","canLinkToPort","Toolkit_1","listeners","locked","clearListeners","data","firing","entity","stopPropagation","removeListener","addListener","uid","setLocked","lockChanged","JumpPointFinderBase","opt","heuristic","Heuristic","trackJumpRecursion","Heap","Util","findPath","startX","startY","endX","endY","openList","f","startNode","getNodeAt","endNode","g","opened","empty","pop","closed","_identifySuccessors","neighbors","neighbor","jumpPoint","jx","jy","ng","jumpNode","_findNeighbors","_jump","h","updateItem","PortModel_1","DefaultLinkModel_1","DefaultPortModel","isInput","label","in","setSourcePort","setTargetPort","DefaultLinkModel","PF","pathFinderInstance","JumpPointFinder","diagonalMovement","PathFinding","diagramEngine","instance","calculateDirectPath","from","to","matrix","getCanvasMatrix","Grid","translateRoutingX","floor","translateRoutingY","calculateLinkStartEndCoords","startIndex","findIndex","endIndex","pathToStart","pathToEnd","start","end","calculateDynamicPath","routingMatrix","dynamicPath","default","Node","walkable","undefined","AStarFinder","allowDiagonal","dontCrossCorners","weight","getNeighbors","BiAStarFinder","cmp","startOpenList","endOpenList","LinkModel_1","DefaultLabelModel_1","LabelModel_1","color","curvyness","addLabel","LabelModel","labelOb","DefaultLabelModel","setLabel","setWidth","widthChanged","setColor","colorChanged","LinkModel","PointModel_1","linkType","sourcePort","targetPort","labels","getLabelFactory","target","source","setPoints","getPoints","isLastPoint","getPointIndex","indexOf","getPointModel","getFirstPoint","getLastPoint","sourcePortChanged","getSourcePort","getTargetPort","targetPortChanged","addPoint","generatePoint","pointModel","splice","removePointsBefore","removePointsAfter","removeMiddlePoints","index","NodeModel_1","DiagramModel","nodes","offsetX","offsetY","zoom","rendered","gridSize","setGridSize","gridUpdated","getGridPosition","pos","deSerializeDiagram","nodeOb","getNodeFactory","addNode","linkOb","getLinkFactory","serializeDiagram","clearSelection","ignore","getSelectedItems","filters","_i","isArray","items","flatMap","uniq","filter","item","includes","setZoomLevel","zoomUpdated","setOffset","offsetUpdated","setOffsetX","setOffsetY","getOffsetY","getOffsetX","getZoomLevel","addAll","models","model","linksUpdated","isCreated","removeNode","nodesUpdated","getNodes","__export","DefaultPortModel_1","DefaultNodeModel","addInPort","addOutPort","getInPorts","portModel","getOutPorts","BaseWidget_1","DefaultLinkWidget","addPointToLink","shiftKey","isModelLocked","getMaxNumberPointsPerLink","getRelativeMousePoint","forceUpdate","pointAdded","findPathAndRelativePositionToRenderLabel","lengths","refPaths","getTotalLength","labelPosition","reduce","previousValue","currentValue","pathIndex","position","calculateLabelPosition","refLabels","labelDimensions","offsetWidth","offsetHeight","pathCentre","getPointAtLength","labelCoordinates","setAttribute","state","isSmartRoutingEnabled","pathFinding","calculateAllLabelPosition","componentDidUpdate","window","requestAnimationFrame","bind","componentDidMount","pointIndex","createElement","key","cx","cy","onMouseLeave","setState","onMouseEnter","data-id","data-linkid","opacity","generateLabel","canvas","ref","getFactoryForLabel","generateReactWidget","generateLink","Bottom","cloneElement","getFactoryForLink","generateLinkSegment","Top","strokeLinecap","strokeOpacity","strokeWidth","onContextMenu","preventDefault","isSmartRoutingApplicable","render","nodesRendered","paths","directPathCoords","first","last","getRoutingMatrix","smartLink","simplifiedPath","onMouseDown","pointLeft","pointRight","i_1","data-point","labelModel","defaultProps","smooth","DefaultPortLabelWidget_1","DefaultNodeWidget","generatePort","DefaultPortLabel","style","background","PortWidget_1","PortWidget","data-name","data-nodeid","AbstractFactory_1","DefaultPortFactory","BaseAction","mouseX","mouseY","ms","Date","getTime","SelectingAction","mouseX2","mouseY2","getBoxDimensions","left","top","right","bottom","containsElement","diagramModel","z","dimensions","MoveCanvasAction","initialOffsetX","initialOffsetY","MoveItemsAction","moved","enableRepaintEntities","getDiagramModel","selectedItems","selectionModels","initialX","initialY","LinkWidget_1","LinkLayerWidget","transform","linksThatHaveInitiallyRendered","portCenter","getPortCenter","portCoords","getPortCoords","generatedLink","generateWidgetForLink","LinkWidget","console","log","shouldComponentUpdate","canEntityRepaint","children","NodeWidget_1","NodeLayerWidget","updateNodeDimensions","getNodeDimensions","NodeWidget","generateWidgetForNode","matches","checkYoSelf","match","el","vendor","querySelectorAll","proto","Element","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","BestFirstFinder","BreadthFirstFinder","DijkstraFinder","BiBestFirstFinder","BiBreadthFirstFinder","BiDijkstraFinder","IDAStarFinder","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","min","nlargest","nsmallest","_siftdown","_siftup","lo","hi","mid","Error","array","lastelt","returnitem","_ref","_len","_ref1","_results","_results1","_j","elem","result","sort","los","startpos","newitem","parentpos","childpos","endpos","rightpos","pushpop","peek","contains","clear","heap","toArray","insert","front","has","copy","webpackPolyfill","deprecate","width_or_matrix","_buildNodes","isInside","setWalkableAt","s0","d0","s1","d1","s2","d2","s3","d3","thisNodes","newGrid","newNodes","orig","shift","by","trackRecursion","timeLimit","Infinity","route","nodesVisited","startTime","cost","search","cutoff","depth","k","neighbour","neighbours","retainCount","tested","cutOff","JPFNeverMoveDiagonally","JPFAlwaysMoveDiagonally","JPFMoveDiagonallyIfNoObstacles","JPFMoveDiagonallyIfAtMostOneObstacle","neighborNodes","neighborNode","isNextWalkable","isTopWalkable","isBottomWalkable","isRightWalkable","isLeftWalkable","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","Symbol","iterator","next","done","TypeError","init","_instructions","areEqualPoints","_ref3","_ref2","a1","b1","_ref32","a2","b2","trimZeros","string","char","charAt","substr","round","number","digits","str","toFixed","printInstrunction","_ref4","command","params","param","join","_ref5","_ref6","_ref62","prevX","prevY","verbosify","keys","args","plus","instruction","hlineto","vlineto","closepath","curveto","x2","y2","smoothcurveto","qcurveto","smoothqcurveto","arc","rx","ry","xrot","largeArcFlag","sweepFlag","ps","prev","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","instructions","connect","newInstructions","unshift","DefaultLinkWidget_1","DefaultLinkFactory","widget","stroke","DefaultNodeModel_1","DefaultNodeWidget_1","DefaultNodeFactory","DiagramModel_1","main_1","DefaultPortFactory_1","DefaultLabelFactory_1","DiagramEngine","canvasMatrix","hAdjustmentFactor","vAdjustmentFactor","calculateMatrixDimensions","allNodesCoords","allLinks","allPortsCoords","allPointsCoords","minX","minBy","maxXElement","maxBy","maxX","minY","maxYElement","maxY","ceil","markNodes","markMatrixPoint","markPorts","nodeFactories","linkFactories","portFactories","labelFactories","paintableWidgets","installDefaultFactories","registerNodeFactory","registerLinkFactory","registerPortFactory","registerLabelFactory","DefaultLabelFactory","repaintCanvas","clearRepaintEntities","recalculatePortsVisually","baseModel","setCanvas","setDiagramModel","getNodeFactories","getLinkFactories","getLabelFactories","labelFactoriesUpdated","portFactoriesUpdated","nodeFactoriesUpdated","linkFactoriesUpdated","getFactoryForNode","linkFactory","nodeFactory","getRelativePoint","clientX","clientY","canvasRect","getBoundingClientRect","getNodeElement","querySelector","getNodePortElement","sourceElement","sourceRect","rel","nodeElement","nodeRect","maxNumberPointsPerLink","setMaxNumberPointsPerLink","smartRouting","setSmartRoutingStatus","status","calculateCanvasMatrix","canvasWidth","canvasHeight","matrixWidth","matrixHeight","range","fill","calculateRoutingMatrix","cloneDeep","zoomToFit","xFactor","clientWidth","scrollWidth","yFactor","clientHeight","scrollHeight","zoomFactor","DefaultLabelWidget_1","DefaultLabelWidget","LinkLayerWidget_1","NodeLayerWidget_1","CanvasActions_1","DiagramWidget","onMouseMove","onMouseUp","action","wasMoved","renderedNodes","windowListener","diagramEngineListener","componentWillUnmount","removeEventListener","onKeyUpPointer","componentWillReceiveProps","nextProps","componentWillUpdate","onKeyUp","addEventListener","focus","getMouseElement","getAttribute","fireAction","actionStillFiring","stopFiringAction","shouldSkipEvent","actionStoppedFiring","startFiringAction","actionStartedFiring","relative","allSelected","amountX_1","amountY_1","amountZoom_1","allowCanvasTranslation","deleteKeys","keyCode","linkConnected","newLink","allowLooseLinks","some","drawSelectionBox","onWheel","allowCanvasZoom","oldZoomFactor","scrollDelta","inverseZoom","deltaY","ctrlKey","boundingRect","currentTarget","widthDiff","heightDiff"],"mappings":"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","file":"main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"_\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"storm-react-diagrams\"] = factory(require(\"lodash\"), require(\"react\"));\n\telse\n\t\troot[\"storm-react-diagrams\"] = factory(root[\"_\"], root[\"React\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"_\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"storm-react-diagrams\"] = factory(require(\"lodash\"), require(\"react\"));\n\telse\n\t\troot[\"storm-react-diagrams\"] = factory(root[\"_\"], root[\"React\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 23);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar BaseWidget = /** @class */ (function (_super) {\n    __extends(BaseWidget, _super);\n    function BaseWidget(name, props) {\n        var _this = _super.call(this, props) || this;\n        _this.className = name;\n        return _this;\n    }\n    BaseWidget.prototype.bem = function (selector) {\n        return (this.props.baseClass || this.className) + selector + \" \";\n    };\n    BaseWidget.prototype.getClassName = function () {\n        return ((this.props.baseClass || this.className) + \" \" + (this.props.className ? this.props.className + \" \" : \"\"));\n    };\n    BaseWidget.prototype.getProps = function () {\n        return __assign({}, (this.props.extraProps || {}), { className: this.getClassName() });\n    };\n    return BaseWidget;\n}(React.Component));\nexports.BaseWidget = BaseWidget;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseEntity_1 = __webpack_require__(12);\nvar _ = __webpack_require__(0);\n/**\n * @author Dylan Vorster\n */\nvar BaseModel = /** @class */ (function (_super) {\n    __extends(BaseModel, _super);\n    function BaseModel(type, id) {\n        var _this = _super.call(this, id) || this;\n        _this.type = type;\n        _this.selected = false;\n        return _this;\n    }\n    BaseModel.prototype.getParent = function () {\n        return this.parent;\n    };\n    BaseModel.prototype.setParent = function (parent) {\n        this.parent = parent;\n    };\n    BaseModel.prototype.getSelectedEntities = function () {\n        if (this.isSelected()) {\n            return [this];\n        }\n        return [];\n    };\n    BaseModel.prototype.deSerialize = function (ob, engine) {\n        _super.prototype.deSerialize.call(this, ob, engine);\n        this.type = ob.type;\n        this.selected = ob.selected;\n    };\n    BaseModel.prototype.serialize = function () {\n        return _.merge(_super.prototype.serialize.call(this), {\n            type: this.type,\n            selected: this.selected\n        });\n    };\n    BaseModel.prototype.getType = function () {\n        return this.type;\n    };\n    BaseModel.prototype.getID = function () {\n        return this.id;\n    };\n    BaseModel.prototype.isSelected = function () {\n        return this.selected;\n    };\n    BaseModel.prototype.setSelected = function (selected) {\n        if (selected === void 0) { selected = true; }\n        this.selected = selected;\n        this.iterateListeners(function (listener, event) {\n            if (listener.selectionChanged) {\n                listener.selectionChanged(__assign({}, event, { isSelected: selected }));\n            }\n        });\n    };\n    BaseModel.prototype.remove = function () {\n        this.iterateListeners(function (listener, event) {\n            if (listener.entityRemoved) {\n                listener.entityRemoved(event);\n            }\n        });\n    };\n    return BaseModel;\n}(BaseEntity_1.BaseEntity));\nexports.BaseModel = BaseModel;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar closest = __webpack_require__(37);\nvar PathFinding_1 = __webpack_require__(16);\nvar Path = __webpack_require__(56);\n/**\n * @author Dylan Vorster\n */\nvar Toolkit = /** @class */ (function () {\n    function Toolkit() {\n    }\n    /**\n     * Generats a unique ID (thanks Stack overflow :3)\n     * @returns {String}\n     */\n    Toolkit.UID = function () {\n        if (Toolkit.TESTING) {\n            Toolkit.TESTING_UID++;\n            return \"\" + Toolkit.TESTING_UID;\n        }\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n            var r = (Math.random() * 16) | 0, v = c == \"x\" ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    };\n    /**\n     * Finds the closest element as a polyfill\n     *\n     * @param  {Element} element  [description]\n     * @param  {string}  selector [description]\n     */\n    Toolkit.closest = function (element, selector) {\n        if (document.body.closest) {\n            return element.closest(selector);\n        }\n        return closest(element, selector);\n    };\n    Toolkit.generateLinePath = function (firstPoint, lastPoint) {\n        return \"M\" + firstPoint.x + \",\" + firstPoint.y + \" L \" + lastPoint.x + \",\" + lastPoint.y;\n    };\n    Toolkit.generateCurvePath = function (firstPoint, lastPoint, curvy) {\n        if (curvy === void 0) { curvy = 0; }\n        return \"M\" + firstPoint.x + \",\" + firstPoint.y + \" C \" + (firstPoint.x + curvy) + \",\" + firstPoint.y + \" \" + (lastPoint.x + -curvy) + \",\" + lastPoint.y + \" \" + lastPoint.x + \",\" + lastPoint.y;\n    };\n    Toolkit.generateDynamicPath = function (pathCoords) {\n        var path = Path();\n        path = path.moveto(pathCoords[0][0] * PathFinding_1.ROUTING_SCALING_FACTOR, pathCoords[0][1] * PathFinding_1.ROUTING_SCALING_FACTOR);\n        pathCoords.slice(1).forEach(function (coords) {\n            path = path.lineto(coords[0] * PathFinding_1.ROUTING_SCALING_FACTOR, coords[1] * PathFinding_1.ROUTING_SCALING_FACTOR);\n        });\n        return path.print();\n    };\n    Toolkit.TESTING = false;\n    Toolkit.TESTING_UID = 0;\n    return Toolkit;\n}());\nexports.Toolkit = Toolkit;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseModel_1 = __webpack_require__(5);\nvar _ = __webpack_require__(0);\nvar PointModel = /** @class */ (function (_super) {\n    __extends(PointModel, _super);\n    function PointModel(link, points) {\n        var _this = _super.call(this) || this;\n        _this.x = points.x;\n        _this.y = points.y;\n        _this.parent = link;\n        return _this;\n    }\n    PointModel.prototype.getSelectedEntities = function () {\n        if (_super.prototype.isSelected.call(this) && !this.isConnectedToPort()) {\n            return [this];\n        }\n        return [];\n    };\n    PointModel.prototype.isConnectedToPort = function () {\n        return this.parent.getPortForPoint(this) !== null;\n    };\n    PointModel.prototype.getLink = function () {\n        return this.getParent();\n    };\n    PointModel.prototype.deSerialize = function (ob, engine) {\n        _super.prototype.deSerialize.call(this, ob, engine);\n        this.x = ob.x;\n        this.y = ob.y;\n    };\n    PointModel.prototype.serialize = function () {\n        return _.merge(_super.prototype.serialize.call(this), {\n            x: this.x,\n            y: this.y\n        });\n    };\n    PointModel.prototype.remove = function () {\n        //clear references\n        if (this.parent) {\n            this.parent.removePoint(this);\n        }\n        _super.prototype.remove.call(this);\n    };\n    PointModel.prototype.updateLocation = function (points) {\n        this.x = points.x;\n        this.y = points.y;\n    };\n    PointModel.prototype.getX = function () {\n        return this.x;\n    };\n    PointModel.prototype.getY = function () {\n        return this.y;\n    };\n    PointModel.prototype.isLocked = function () {\n        return _super.prototype.isLocked.call(this) || this.getParent().isLocked();\n    };\n    return PointModel;\n}(BaseModel_1.BaseModel));\nexports.PointModel = PointModel;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseModel_1 = __webpack_require__(5);\nvar _ = __webpack_require__(0);\nvar NodeModel = /** @class */ (function (_super) {\n    __extends(NodeModel, _super);\n    function NodeModel(nodeType, id) {\n        if (nodeType === void 0) { nodeType = \"default\"; }\n        var _this = _super.call(this, nodeType, id) || this;\n        _this.x = 0;\n        _this.y = 0;\n        _this.extras = {};\n        _this.ports = {};\n        return _this;\n    }\n    NodeModel.prototype.setPosition = function (x, y) {\n        var _this = this;\n        //store position\n        var oldX = this.x;\n        var oldY = this.y;\n        var _loop_1 = function (port) {\n            _.forEach(this_1.ports[port].getLinks(), function (link) {\n                var point = link.getPointForPort(_this.ports[port]);\n                point.x = point.x + x - oldX;\n                point.y = point.y + y - oldY;\n            });\n        };\n        var this_1 = this;\n        for (var port in this.ports) {\n            _loop_1(port);\n        }\n        this.x = x;\n        this.y = y;\n    };\n    NodeModel.prototype.getSelectedEntities = function () {\n        var _this = this;\n        var entities = _super.prototype.getSelectedEntities.call(this);\n        // add the points of each link that are selected here\n        if (this.isSelected()) {\n            var _loop_2 = function (portName) {\n                entities = entities.concat(_.map(this_2.ports[portName].getLinks(), function (link) {\n                    return link.getPointForPort(_this.ports[portName]);\n                }));\n            };\n            var this_2 = this;\n            for (var portName in this.ports) {\n                _loop_2(portName);\n            }\n        }\n        return entities;\n    };\n    NodeModel.prototype.deSerialize = function (ob, engine) {\n        var _this = this;\n        _super.prototype.deSerialize.call(this, ob, engine);\n        this.x = ob.x;\n        this.y = ob.y;\n        this.extras = ob.extras;\n        //deserialize ports\n        _.forEach(ob.ports, function (port) {\n            var portOb = engine.getPortFactory(port.type).getNewInstance();\n            portOb.deSerialize(port, engine);\n            _this.addPort(portOb);\n        });\n    };\n    NodeModel.prototype.serialize = function () {\n        return _.merge(_super.prototype.serialize.call(this), {\n            x: this.x,\n            y: this.y,\n            extras: this.extras,\n            ports: _.map(this.ports, function (port) {\n                return port.serialize();\n            })\n        });\n    };\n    NodeModel.prototype.doClone = function (lookupTable, clone) {\n        if (lookupTable === void 0) { lookupTable = {}; }\n        // also clone the ports\n        clone.ports = {};\n        _.values(this.ports).forEach(function (port) {\n            clone.addPort(port.clone(lookupTable));\n        });\n    };\n    NodeModel.prototype.remove = function () {\n        _super.prototype.remove.call(this);\n        for (var i in this.ports) {\n            _.forEach(this.ports[i].getLinks(), function (link) {\n                link.remove();\n            });\n        }\n    };\n    NodeModel.prototype.getPortFromID = function (id) {\n        for (var i in this.ports) {\n            if (this.ports[i].id === id) {\n                return this.ports[i];\n            }\n        }\n        return null;\n    };\n    NodeModel.prototype.getPort = function (name) {\n        return this.ports[name];\n    };\n    NodeModel.prototype.getPorts = function () {\n        return this.ports;\n    };\n    NodeModel.prototype.removePort = function (port) {\n        //clear the parent node reference\n        if (this.ports[port.name]) {\n            this.ports[port.name].setParent(null);\n            delete this.ports[port.name];\n        }\n    };\n    NodeModel.prototype.addPort = function (port) {\n        port.setParent(this);\n        this.ports[port.name] = port;\n        return port;\n    };\n    NodeModel.prototype.updateDimensions = function (_a) {\n        var width = _a.width, height = _a.height;\n        this.width = width;\n        this.height = height;\n    };\n    return NodeModel;\n}(BaseModel_1.BaseModel));\nexports.NodeModel = NodeModel;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractFactory = /** @class */ (function () {\n    function AbstractFactory(name) {\n        this.type = name;\n    }\n    AbstractFactory.prototype.getType = function () {\n        return this.type;\n    };\n    return AbstractFactory;\n}());\nexports.AbstractFactory = AbstractFactory;\nvar NodeFactory = /** @class */ (function (_super) {\n    __extends(NodeFactory, _super);\n    function NodeFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return NodeFactory;\n}(AbstractFactory));\nexports.NodeFactory = NodeFactory;\nvar LinkFactory = /** @class */ (function (_super) {\n    __extends(LinkFactory, _super);\n    function LinkFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LinkFactory;\n}(AbstractFactory));\nexports.LinkFactory = LinkFactory;\nvar LabelFactory = /** @class */ (function (_super) {\n    __extends(LabelFactory, _super);\n    function LabelFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LabelFactory;\n}(AbstractFactory));\nexports.LabelFactory = LabelFactory;\nvar PortFactory = /** @class */ (function (_super) {\n    __extends(PortFactory, _super);\n    function PortFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PortFactory;\n}(AbstractFactory));\nexports.PortFactory = PortFactory;\nvar SimplePortFactory = /** @class */ (function (_super) {\n    __extends(SimplePortFactory, _super);\n    function SimplePortFactory(type, cb) {\n        var _this = _super.call(this, type) || this;\n        _this.cb = cb;\n        return _this;\n    }\n    SimplePortFactory.prototype.getNewInstance = function (initialConfig) {\n        return this.cb(initialConfig);\n    };\n    return SimplePortFactory;\n}(PortFactory));\nexports.SimplePortFactory = SimplePortFactory;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseModel_1 = __webpack_require__(5);\nvar _ = __webpack_require__(0);\nvar PortModel = /** @class */ (function (_super) {\n    __extends(PortModel, _super);\n    function PortModel(name, type, id, maximumLinks) {\n        var _this = _super.call(this, type, id) || this;\n        _this.name = name;\n        _this.links = {};\n        _this.maximumLinks = maximumLinks;\n        return _this;\n    }\n    PortModel.prototype.deSerialize = function (ob, engine) {\n        _super.prototype.deSerialize.call(this, ob, engine);\n        this.name = ob.name;\n        this.maximumLinks = ob.maximumLinks;\n    };\n    PortModel.prototype.serialize = function () {\n        return _.merge(_super.prototype.serialize.call(this), {\n            name: this.name,\n            parentNode: this.parent.id,\n            links: _.map(this.links, function (link) {\n                return link.id;\n            }),\n            maximumLinks: this.maximumLinks\n        });\n    };\n    PortModel.prototype.doClone = function (lookupTable, clone) {\n        if (lookupTable === void 0) { lookupTable = {}; }\n        clone.links = {};\n        clone.parentNode = this.getParent().clone(lookupTable);\n    };\n    PortModel.prototype.getNode = function () {\n        return this.getParent();\n    };\n    PortModel.prototype.getName = function () {\n        return this.name;\n    };\n    PortModel.prototype.getMaximumLinks = function () {\n        return this.maximumLinks;\n    };\n    PortModel.prototype.setMaximumLinks = function (maximumLinks) {\n        this.maximumLinks = maximumLinks;\n    };\n    PortModel.prototype.removeLink = function (link) {\n        delete this.links[link.getID()];\n    };\n    PortModel.prototype.addLink = function (link) {\n        this.links[link.getID()] = link;\n    };\n    PortModel.prototype.getLinks = function () {\n        return this.links;\n    };\n    PortModel.prototype.createLinkModel = function () {\n        if (_.isFinite(this.maximumLinks)) {\n            var numberOfLinks = _.size(this.links);\n            if (this.maximumLinks === 1 && numberOfLinks >= 1) {\n                return _.values(this.links)[0];\n            }\n            else if (numberOfLinks >= this.maximumLinks) {\n                return null;\n            }\n        }\n        return null;\n    };\n    PortModel.prototype.updateCoords = function (_a) {\n        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    };\n    PortModel.prototype.canLinkToPort = function (port) {\n        return true;\n    };\n    PortModel.prototype.isLocked = function () {\n        return _super.prototype.isLocked.call(this) || this.getParent().isLocked();\n    };\n    return PortModel;\n}(BaseModel_1.BaseModel));\nexports.PortModel = PortModel;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Toolkit_1 = __webpack_require__(6);\nvar _ = __webpack_require__(0);\nvar BaseEntity = /** @class */ (function () {\n    function BaseEntity(id) {\n        this.listeners = {};\n        this.id = id || Toolkit_1.Toolkit.UID();\n        this.locked = false;\n    }\n    BaseEntity.prototype.getID = function () {\n        return this.id;\n    };\n    BaseEntity.prototype.doClone = function (lookupTable, clone) {\n        if (lookupTable === void 0) { lookupTable = {}; }\n    };\n    BaseEntity.prototype.clone = function (lookupTable) {\n        if (lookupTable === void 0) { lookupTable = {}; }\n        // try and use an existing clone first\n        if (lookupTable[this.id]) {\n            return lookupTable[this.id];\n        }\n        var clone = _.clone(this);\n        clone.id = Toolkit_1.Toolkit.UID();\n        clone.clearListeners();\n        lookupTable[this.id] = clone;\n        this.doClone(lookupTable, clone);\n        return clone;\n    };\n    BaseEntity.prototype.clearListeners = function () {\n        this.listeners = {};\n    };\n    BaseEntity.prototype.deSerialize = function (data, engine) {\n        this.id = data.id;\n    };\n    BaseEntity.prototype.serialize = function () {\n        return {\n            id: this.id\n        };\n    };\n    BaseEntity.prototype.iterateListeners = function (cb) {\n        var event = {\n            id: Toolkit_1.Toolkit.UID(),\n            firing: true,\n            entity: this,\n            stopPropagation: function () {\n                event.firing = false;\n            }\n        };\n        for (var i in this.listeners) {\n            // propagation stopped\n            if (!event.firing) {\n                return;\n            }\n            cb(this.listeners[i], event);\n        }\n    };\n    BaseEntity.prototype.removeListener = function (listener) {\n        if (this.listeners[listener]) {\n            delete this.listeners[listener];\n            return true;\n        }\n        return false;\n    };\n    BaseEntity.prototype.addListener = function (listener) {\n        var uid = Toolkit_1.Toolkit.UID();\n        this.listeners[uid] = listener;\n        return uid;\n    };\n    BaseEntity.prototype.isLocked = function () {\n        return this.locked;\n    };\n    BaseEntity.prototype.setLocked = function (locked) {\n        if (locked === void 0) { locked = true; }\n        this.locked = locked;\n        this.iterateListeners(function (listener, event) {\n            if (listener.lockChanged) {\n                listener.lockChanged(__assign({}, event, { locked: locked }));\n            }\n        });\n    };\n    return BaseEntity;\n}());\nexports.BaseEntity = BaseEntity;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(41);\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = __webpack_require__(13);\r\nvar Util       = __webpack_require__(4);\r\nvar Heuristic  = __webpack_require__(8);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = __webpack_require__(0);\nvar PortModel_1 = __webpack_require__(11);\nvar DefaultLinkModel_1 = __webpack_require__(20);\nvar DefaultPortModel = /** @class */ (function (_super) {\n    __extends(DefaultPortModel, _super);\n    function DefaultPortModel(isInput, name, label, id) {\n        if (label === void 0) { label = null; }\n        var _this = _super.call(this, name, \"default\", id) || this;\n        _this.in = isInput;\n        _this.label = label || name;\n        return _this;\n    }\n    DefaultPortModel.prototype.deSerialize = function (object, engine) {\n        _super.prototype.deSerialize.call(this, object, engine);\n        this.in = object.in;\n        this.label = object.label;\n    };\n    DefaultPortModel.prototype.serialize = function () {\n        return _.merge(_super.prototype.serialize.call(this), {\n            in: this.in,\n            label: this.label\n        });\n    };\n    DefaultPortModel.prototype.link = function (port) {\n        var link = this.createLinkModel();\n        link.setSourcePort(this);\n        link.setTargetPort(port);\n        return link;\n    };\n    DefaultPortModel.prototype.canLinkToPort = function (port) {\n        if (port instanceof DefaultPortModel) {\n            return this.in !== port.in;\n        }\n        return true;\n    };\n    DefaultPortModel.prototype.createLinkModel = function () {\n        var link = _super.prototype.createLinkModel.call(this);\n        return link || new DefaultLinkModel_1.DefaultLinkModel();\n    };\n    return DefaultPortModel;\n}(PortModel_1.PortModel));\nexports.DefaultPortModel = DefaultPortModel;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PF = __webpack_require__(39);\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\nexports.ROUTING_SCALING_FACTOR = 5;\nvar pathFinderInstance = new PF.JumpPointFinder({\n    heuristic: PF.Heuristic.manhattan,\n    diagonalMovement: PF.DiagonalMovement.Never\n});\nvar PathFinding = /** @class */ (function () {\n    function PathFinding(diagramEngine) {\n        this.instance = pathFinderInstance;\n        this.diagramEngine = diagramEngine;\n    }\n    /**\n     * Taking as argument a fully unblocked walking matrix, this method\n     * finds a direct path from point A to B.\n     */\n    PathFinding.prototype.calculateDirectPath = function (from, to) {\n        var matrix = this.diagramEngine.getCanvasMatrix();\n        var grid = new PF.Grid(matrix);\n        return pathFinderInstance.findPath(this.diagramEngine.translateRoutingX(Math.floor(from.x / exports.ROUTING_SCALING_FACTOR)), this.diagramEngine.translateRoutingY(Math.floor(from.y / exports.ROUTING_SCALING_FACTOR)), this.diagramEngine.translateRoutingX(Math.floor(to.x / exports.ROUTING_SCALING_FACTOR)), this.diagramEngine.translateRoutingY(Math.floor(to.y / exports.ROUTING_SCALING_FACTOR)), grid);\n    };\n    /**\n     * Using @link{#calculateDirectPath}'s result as input, we here\n     * determine the first walkable point found in the matrix that includes\n     * blocked paths.\n     */\n    PathFinding.prototype.calculateLinkStartEndCoords = function (matrix, path) {\n        var startIndex = path.findIndex(function (point) { return matrix[point[1]][point[0]] === 0; });\n        var endIndex = path.length -\n            1 -\n            path\n                .slice()\n                .reverse()\n                .findIndex(function (point) { return matrix[point[1]][point[0]] === 0; });\n        // are we trying to create a path exclusively through blocked areas?\n        // if so, let's fallback to the linear routing\n        if (startIndex === -1 || endIndex === -1) {\n            return undefined;\n        }\n        var pathToStart = path.slice(0, startIndex);\n        var pathToEnd = path.slice(endIndex);\n        return {\n            start: {\n                x: path[startIndex][0],\n                y: path[startIndex][1]\n            },\n            end: {\n                x: path[endIndex][0],\n                y: path[endIndex][1]\n            },\n            pathToStart: pathToStart,\n            pathToEnd: pathToEnd\n        };\n    };\n    /**\n     * Puts everything together: merges the paths from/to the centre of the ports,\n     * with the path calculated around other elements.\n     */\n    PathFinding.prototype.calculateDynamicPath = function (routingMatrix, start, end, pathToStart, pathToEnd) {\n        var _this = this;\n        // generate the path based on the matrix with obstacles\n        var grid = new PF.Grid(routingMatrix);\n        var dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n        // aggregate everything to have the calculated path ready for rendering\n        var pathCoords = pathToStart\n            .concat(dynamicPath, pathToEnd)\n            .map(function (coords) { return [\n            _this.diagramEngine.translateRoutingX(coords[0], true),\n            _this.diagramEngine.translateRoutingY(coords[1], true)\n        ]; });\n        return PF.Util.compressPath(pathCoords);\n    };\n    return PathFinding;\n}());\nexports.default = PathFinding;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\r\nfunction Node(x, y, walkable) {\r\n    /**\r\n     * The x coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.x = x;\r\n    /**\r\n     * The y coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.y = y;\r\n    /**\r\n     * Whether this node can be walked through.\r\n     * @type boolean\r\n     */\r\n    this.walkable = (walkable === undefined ? true : walkable);\r\n}\r\n\r\nmodule.exports = Node;\r\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Heap       = __webpack_require__(13);\r\nvar Util       = __webpack_require__(4);\r\nvar Heuristic  = __webpack_require__(8);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Heap       = __webpack_require__(13);\r\nvar Util       = __webpack_require__(4);\r\nvar Heuristic  = __webpack_require__(8);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @author Dylan Vorster\n */\nvar LinkModel_1 = __webpack_require__(21);\nvar _ = __webpack_require__(0);\nvar DefaultLabelModel_1 = __webpack_require__(25);\nvar LabelModel_1 = __webpack_require__(26);\nvar DefaultLinkModel = /** @class */ (function (_super) {\n    __extends(DefaultLinkModel, _super);\n    function DefaultLinkModel(type) {\n        if (type === void 0) { type = \"default\"; }\n        var _this = _super.call(this, type) || this;\n        _this.color = \"rgba(255,255,255,0.5)\";\n        _this.width = 3;\n        _this.curvyness = 50;\n        return _this;\n    }\n    DefaultLinkModel.prototype.serialize = function () {\n        return _.merge(_super.prototype.serialize.call(this), {\n            width: this.width,\n            color: this.color,\n            curvyness: this.curvyness\n        });\n    };\n    DefaultLinkModel.prototype.deSerialize = function (ob, engine) {\n        _super.prototype.deSerialize.call(this, ob, engine);\n        this.color = ob.color;\n        this.width = ob.width;\n        this.curvyness = ob.curvyness;\n    };\n    DefaultLinkModel.prototype.addLabel = function (label) {\n        if (label instanceof LabelModel_1.LabelModel) {\n            return _super.prototype.addLabel.call(this, label);\n        }\n        var labelOb = new DefaultLabelModel_1.DefaultLabelModel();\n        labelOb.setLabel(label);\n        return _super.prototype.addLabel.call(this, labelOb);\n    };\n    DefaultLinkModel.prototype.setWidth = function (width) {\n        this.width = width;\n        this.iterateListeners(function (listener, event) {\n            listener.widthChanged && listener.widthChanged(__assign({}, event, { width: width }));\n        });\n    };\n    DefaultLinkModel.prototype.setColor = function (color) {\n        this.color = color;\n        this.iterateListeners(function (listener, event) {\n            listener.colorChanged && listener.colorChanged(__assign({}, event, { color: color }));\n        });\n    };\n    return DefaultLinkModel;\n}(LinkModel_1.LinkModel));\nexports.DefaultLinkModel = DefaultLinkModel;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseModel_1 = __webpack_require__(5);\nvar PointModel_1 = __webpack_require__(7);\nvar _ = __webpack_require__(0);\nvar LinkModel = /** @class */ (function (_super) {\n    __extends(LinkModel, _super);\n    function LinkModel(linkType, id) {\n        if (linkType === void 0) { linkType = \"default\"; }\n        var _this = _super.call(this, linkType, id) || this;\n        _this.points = [new PointModel_1.PointModel(_this, { x: 0, y: 0 }), new PointModel_1.PointModel(_this, { x: 0, y: 0 })];\n        _this.extras = {};\n        _this.sourcePort = null;\n        _this.targetPort = null;\n        _this.labels = [];\n        return _this;\n    }\n    LinkModel.prototype.deSerialize = function (ob, engine) {\n        var _this = this;\n        _super.prototype.deSerialize.call(this, ob, engine);\n        this.extras = ob.extras;\n        this.points = _.map(ob.points || [], function (point) {\n            var p = new PointModel_1.PointModel(_this, { x: point.x, y: point.y });\n            p.deSerialize(point, engine);\n            return p;\n        });\n        //deserialize labels\n        _.forEach(ob.labels || [], function (label) {\n            var labelOb = engine.getLabelFactory(label.type).getNewInstance();\n            labelOb.deSerialize(label, engine);\n            _this.addLabel(labelOb);\n        });\n        if (ob.target) {\n            this.setTargetPort(this.getParent()\n                .getNode(ob.target)\n                .getPortFromID(ob.targetPort));\n        }\n        if (ob.source) {\n            this.setSourcePort(this.getParent()\n                .getNode(ob.source)\n                .getPortFromID(ob.sourcePort));\n        }\n    };\n    LinkModel.prototype.serialize = function () {\n        return _.merge(_super.prototype.serialize.call(this), {\n            source: this.sourcePort ? this.sourcePort.getParent().id : null,\n            sourcePort: this.sourcePort ? this.sourcePort.id : null,\n            target: this.targetPort ? this.targetPort.getParent().id : null,\n            targetPort: this.targetPort ? this.targetPort.id : null,\n            points: _.map(this.points, function (point) {\n                return point.serialize();\n            }),\n            extras: this.extras,\n            labels: _.map(this.labels, function (label) {\n                return label.serialize();\n            })\n        });\n    };\n    LinkModel.prototype.doClone = function (lookupTable, clone) {\n        if (lookupTable === void 0) { lookupTable = {}; }\n        clone.setPoints(_.map(this.getPoints(), function (point) {\n            return point.clone(lookupTable);\n        }));\n        if (this.sourcePort) {\n            clone.setSourcePort(this.sourcePort.clone(lookupTable));\n        }\n        if (this.targetPort) {\n            clone.setTargetPort(this.targetPort.clone(lookupTable));\n        }\n    };\n    LinkModel.prototype.remove = function () {\n        if (this.sourcePort) {\n            this.sourcePort.removeLink(this);\n        }\n        if (this.targetPort) {\n            this.targetPort.removeLink(this);\n        }\n        _super.prototype.remove.call(this);\n    };\n    LinkModel.prototype.isLastPoint = function (point) {\n        var index = this.getPointIndex(point);\n        return index === this.points.length - 1;\n    };\n    LinkModel.prototype.getPointIndex = function (point) {\n        return this.points.indexOf(point);\n    };\n    LinkModel.prototype.getPointModel = function (id) {\n        for (var i = 0; i < this.points.length; i++) {\n            if (this.points[i].id === id) {\n                return this.points[i];\n            }\n        }\n        return null;\n    };\n    LinkModel.prototype.getPortForPoint = function (point) {\n        if (this.sourcePort !== null && this.getFirstPoint().getID() === point.getID()) {\n            return this.sourcePort;\n        }\n        if (this.targetPort !== null && this.getLastPoint().getID() === point.getID()) {\n            return this.targetPort;\n        }\n        return null;\n    };\n    LinkModel.prototype.getPointForPort = function (port) {\n        if (this.sourcePort !== null && this.sourcePort.getID() === port.getID()) {\n            return this.getFirstPoint();\n        }\n        if (this.targetPort !== null && this.targetPort.getID() === port.getID()) {\n            return this.getLastPoint();\n        }\n        return null;\n    };\n    LinkModel.prototype.getFirstPoint = function () {\n        return this.points[0];\n    };\n    LinkModel.prototype.getLastPoint = function () {\n        return this.points[this.points.length - 1];\n    };\n    LinkModel.prototype.setSourcePort = function (port) {\n        if (port !== null) {\n            port.addLink(this);\n        }\n        else if (this.sourcePort !== null) {\n            this.sourcePort.removeLink(this);\n        }\n        else {\n            return;\n        }\n        this.sourcePort = port;\n        this.iterateListeners(function (listener, event) {\n            listener.sourcePortChanged && listener.sourcePortChanged(__assign({}, event, { port: port }));\n        });\n    };\n    LinkModel.prototype.getSourcePort = function () {\n        return this.sourcePort;\n    };\n    LinkModel.prototype.getTargetPort = function () {\n        return this.targetPort;\n    };\n    LinkModel.prototype.setTargetPort = function (port) {\n        if (port !== null) {\n            port.addLink(this);\n        }\n        else if (this.targetPort !== null) {\n            this.targetPort.removeLink(this);\n        }\n        else {\n            return;\n        }\n        this.targetPort = port;\n        this.iterateListeners(function (listener, event) {\n            listener.targetPortChanged && listener.targetPortChanged(__assign({}, event, { port: port }));\n        });\n    };\n    LinkModel.prototype.point = function (x, y) {\n        return this.addPoint(this.generatePoint(x, y));\n    };\n    LinkModel.prototype.addLabel = function (label) {\n        label.setParent(this);\n        this.labels.push(label);\n    };\n    LinkModel.prototype.getPoints = function () {\n        return this.points;\n    };\n    LinkModel.prototype.setPoints = function (points) {\n        var _this = this;\n        _.forEach(points, function (point) {\n            point.setParent(_this);\n        });\n        this.points = points;\n    };\n    LinkModel.prototype.removePoint = function (pointModel) {\n        this.points.splice(this.getPointIndex(pointModel), 1);\n    };\n    LinkModel.prototype.removePointsBefore = function (pointModel) {\n        this.points.splice(0, this.getPointIndex(pointModel));\n    };\n    LinkModel.prototype.removePointsAfter = function (pointModel) {\n        this.points.splice(this.getPointIndex(pointModel) + 1);\n    };\n    LinkModel.prototype.removeMiddlePoints = function () {\n        if (this.points.length > 2) {\n            this.points.splice(0, this.points.length - 2);\n        }\n    };\n    LinkModel.prototype.addPoint = function (pointModel, index) {\n        if (index === void 0) { index = 1; }\n        pointModel.setParent(this);\n        this.points.splice(index, 0, pointModel);\n        return pointModel;\n    };\n    LinkModel.prototype.generatePoint = function (x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        return new PointModel_1.PointModel(this, { x: x, y: y });\n    };\n    return LinkModel;\n}(BaseModel_1.BaseModel));\nexports.LinkModel = LinkModel;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseEntity_1 = __webpack_require__(12);\nvar _ = __webpack_require__(0);\nvar LinkModel_1 = __webpack_require__(21);\nvar NodeModel_1 = __webpack_require__(9);\nvar PortModel_1 = __webpack_require__(11);\nvar PointModel_1 = __webpack_require__(7);\n/**\n *\n */\nvar DiagramModel = /** @class */ (function (_super) {\n    __extends(DiagramModel, _super);\n    function DiagramModel() {\n        var _this = _super.call(this) || this;\n        _this.links = {};\n        _this.nodes = {};\n        _this.offsetX = 0;\n        _this.offsetY = 0;\n        _this.zoom = 100;\n        _this.rendered = false;\n        _this.gridSize = 0;\n        return _this;\n    }\n    DiagramModel.prototype.setGridSize = function (size) {\n        if (size === void 0) { size = 0; }\n        this.gridSize = size;\n        this.iterateListeners(function (listener, event) {\n            listener.gridUpdated && listener.gridUpdated(__assign({}, event, { size: size }));\n        });\n    };\n    DiagramModel.prototype.getGridPosition = function (pos) {\n        if (this.gridSize === 0) {\n            return pos;\n        }\n        return this.gridSize * Math.floor((pos + this.gridSize / 2) / this.gridSize);\n    };\n    DiagramModel.prototype.deSerializeDiagram = function (object, diagramEngine) {\n        var _this = this;\n        this.deSerialize(object, diagramEngine);\n        this.offsetX = object.offsetX;\n        this.offsetY = object.offsetY;\n        this.zoom = object.zoom;\n        this.gridSize = object.gridSize;\n        // deserialize nodes\n        _.forEach(object.nodes, function (node) {\n            var nodeOb = diagramEngine.getNodeFactory(node.type).getNewInstance(node);\n            nodeOb.setParent(_this);\n            nodeOb.deSerialize(node, diagramEngine);\n            _this.addNode(nodeOb);\n        });\n        // deserialze links\n        _.forEach(object.links, function (link) {\n            var linkOb = diagramEngine.getLinkFactory(link.type).getNewInstance();\n            linkOb.setParent(_this);\n            linkOb.deSerialize(link, diagramEngine);\n            _this.addLink(linkOb);\n        });\n    };\n    DiagramModel.prototype.serializeDiagram = function () {\n        return _.merge(this.serialize(), {\n            offsetX: this.offsetX,\n            offsetY: this.offsetY,\n            zoom: this.zoom,\n            gridSize: this.gridSize,\n            links: _.map(this.links, function (link) {\n                return link.serialize();\n            }),\n            nodes: _.map(this.nodes, function (node) {\n                return node.serialize();\n            })\n        });\n    };\n    DiagramModel.prototype.clearSelection = function (ignore) {\n        if (ignore === void 0) { ignore = null; }\n        _.forEach(this.getSelectedItems(), function (element) {\n            if (ignore && ignore.getID() === element.getID()) {\n                return;\n            }\n            element.setSelected(false); //TODO dont fire the listener\n        });\n    };\n    DiagramModel.prototype.getSelectedItems = function () {\n        var filters = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            filters[_i] = arguments[_i];\n        }\n        if (!Array.isArray(filters)) {\n            filters = [filters];\n        }\n        var items = [];\n        // run through nodes\n        items = items.concat(_.flatMap(this.nodes, function (node) {\n            return node.getSelectedEntities();\n        }));\n        // find all the links\n        items = items.concat(_.flatMap(this.links, function (link) {\n            return link.getSelectedEntities();\n        }));\n        //find all points\n        items = items.concat(_.flatMap(this.links, function (link) {\n            return _.flatMap(link.points, function (point) {\n                return point.getSelectedEntities();\n            });\n        }));\n        items = _.uniq(items);\n        if (filters.length > 0) {\n            items = _.filter(_.uniq(items), function (item) {\n                if (_.includes(filters, \"node\") && item instanceof NodeModel_1.NodeModel) {\n                    return true;\n                }\n                if (_.includes(filters, \"link\") && item instanceof LinkModel_1.LinkModel) {\n                    return true;\n                }\n                if (_.includes(filters, \"port\") && item instanceof PortModel_1.PortModel) {\n                    return true;\n                }\n                if (_.includes(filters, \"point\") && item instanceof PointModel_1.PointModel) {\n                    return true;\n                }\n                return false;\n            });\n        }\n        return items;\n    };\n    DiagramModel.prototype.setZoomLevel = function (zoom) {\n        this.zoom = zoom;\n        this.iterateListeners(function (listener, event) {\n            listener.zoomUpdated && listener.zoomUpdated(__assign({}, event, { zoom: zoom }));\n        });\n    };\n    DiagramModel.prototype.setOffset = function (offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.iterateListeners(function (listener, event) {\n            listener.offsetUpdated && listener.offsetUpdated(__assign({}, event, { offsetX: offsetX, offsetY: offsetY }));\n        });\n    };\n    DiagramModel.prototype.setOffsetX = function (offsetX) {\n        var _this = this;\n        this.offsetX = offsetX;\n        this.iterateListeners(function (listener, event) {\n            listener.offsetUpdated && listener.offsetUpdated(__assign({}, event, { offsetX: offsetX, offsetY: _this.offsetY }));\n        });\n    };\n    DiagramModel.prototype.setOffsetY = function (offsetY) {\n        var _this = this;\n        this.offsetY = offsetY;\n        this.iterateListeners(function (listener, event) {\n            listener.offsetUpdated &&\n                listener.offsetUpdated(__assign({}, event, { offsetX: _this.offsetX, offsetY: _this.offsetY }));\n        });\n    };\n    DiagramModel.prototype.getOffsetY = function () {\n        return this.offsetY;\n    };\n    DiagramModel.prototype.getOffsetX = function () {\n        return this.offsetX;\n    };\n    DiagramModel.prototype.getZoomLevel = function () {\n        return this.zoom;\n    };\n    DiagramModel.prototype.getNode = function (node) {\n        if (node instanceof NodeModel_1.NodeModel) {\n            return node;\n        }\n        if (!this.nodes[node]) {\n            return null;\n        }\n        return this.nodes[node];\n    };\n    DiagramModel.prototype.getLink = function (link) {\n        if (link instanceof LinkModel_1.LinkModel) {\n            return link;\n        }\n        if (!this.links[link]) {\n            return null;\n        }\n        return this.links[link];\n    };\n    DiagramModel.prototype.addAll = function () {\n        var _this = this;\n        var models = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            models[_i] = arguments[_i];\n        }\n        _.forEach(models, function (model) {\n            if (model instanceof LinkModel_1.LinkModel) {\n                _this.addLink(model);\n            }\n            else if (model instanceof NodeModel_1.NodeModel) {\n                _this.addNode(model);\n            }\n        });\n        return models;\n    };\n    DiagramModel.prototype.addLink = function (link) {\n        var _this = this;\n        link.addListener({\n            entityRemoved: function () {\n                _this.removeLink(link);\n            }\n        });\n        this.links[link.getID()] = link;\n        this.iterateListeners(function (listener, event) {\n            listener.linksUpdated && listener.linksUpdated(__assign({}, event, { link: link, isCreated: true }));\n        });\n        return link;\n    };\n    DiagramModel.prototype.addNode = function (node) {\n        var _this = this;\n        node.addListener({\n            entityRemoved: function () {\n                _this.removeNode(node);\n            }\n        });\n        this.nodes[node.getID()] = node;\n        this.iterateListeners(function (listener, event) {\n            listener.nodesUpdated && listener.nodesUpdated(__assign({}, event, { node: node, isCreated: true }));\n        });\n        return node;\n    };\n    DiagramModel.prototype.removeLink = function (link) {\n        link = this.getLink(link);\n        delete this.links[link.getID()];\n        this.iterateListeners(function (listener, event) {\n            listener.linksUpdated && listener.linksUpdated(__assign({}, event, { link: link, isCreated: false }));\n        });\n    };\n    DiagramModel.prototype.removeNode = function (node) {\n        node = this.getNode(node);\n        delete this.nodes[node.getID()];\n        this.iterateListeners(function (listener, event) {\n            listener.nodesUpdated && listener.nodesUpdated(__assign({}, event, { node: node, isCreated: false }));\n        });\n    };\n    DiagramModel.prototype.getLinks = function () {\n        return this.links;\n    };\n    DiagramModel.prototype.getNodes = function () {\n        return this.nodes;\n    };\n    return DiagramModel;\n}(BaseEntity_1.BaseEntity));\nexports.DiagramModel = DiagramModel;\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author Dylan Vorster\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//export defaults\n__export(__webpack_require__(24));\n__export(__webpack_require__(15));\n__export(__webpack_require__(20));\n__export(__webpack_require__(57));\n__export(__webpack_require__(58));\n__export(__webpack_require__(31));\n__export(__webpack_require__(27));\n__export(__webpack_require__(28));\n__export(__webpack_require__(29));\n__export(__webpack_require__(10));\n__export(__webpack_require__(6));\n__export(__webpack_require__(59));\n__export(__webpack_require__(22));\n__export(__webpack_require__(12));\n__export(__webpack_require__(32));\n__export(__webpack_require__(5));\n__export(__webpack_require__(22));\n__export(__webpack_require__(21));\n__export(__webpack_require__(9));\n__export(__webpack_require__(7));\n__export(__webpack_require__(11));\n__export(__webpack_require__(62));\n__export(__webpack_require__(33));\n__export(__webpack_require__(34));\n__export(__webpack_require__(35));\n__export(__webpack_require__(36));\n__export(__webpack_require__(30));\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DefaultPortModel_1 = __webpack_require__(15);\nvar _ = __webpack_require__(0);\nvar NodeModel_1 = __webpack_require__(9);\nvar Toolkit_1 = __webpack_require__(6);\n/**\n * @author Dylan Vorster\n */\nvar DefaultNodeModel = /** @class */ (function (_super) {\n    __extends(DefaultNodeModel, _super);\n    function DefaultNodeModel(name, color) {\n        if (name === void 0) { name = \"Untitled\"; }\n        if (color === void 0) { color = \"rgb(0,192,255)\"; }\n        var _this = _super.call(this, \"default\") || this;\n        _this.name = name;\n        _this.color = color;\n        return _this;\n    }\n    DefaultNodeModel.prototype.addInPort = function (label) {\n        return this.addPort(new DefaultPortModel_1.DefaultPortModel(true, Toolkit_1.Toolkit.UID(), label));\n    };\n    DefaultNodeModel.prototype.addOutPort = function (label) {\n        return this.addPort(new DefaultPortModel_1.DefaultPortModel(false, Toolkit_1.Toolkit.UID(), label));\n    };\n    DefaultNodeModel.prototype.deSerialize = function (object, engine) {\n        _super.prototype.deSerialize.call(this, object, engine);\n        this.name = object.name;\n        this.color = object.color;\n    };\n    DefaultNodeModel.prototype.serialize = function () {\n        return _.merge(_super.prototype.serialize.call(this), {\n            name: this.name,\n            color: this.color\n        });\n    };\n    DefaultNodeModel.prototype.getInPorts = function () {\n        return _.filter(this.ports, function (portModel) {\n            return portModel.in;\n        });\n    };\n    DefaultNodeModel.prototype.getOutPorts = function () {\n        return _.filter(this.ports, function (portModel) {\n            return !portModel.in;\n        });\n    };\n    return DefaultNodeModel;\n}(NodeModel_1.NodeModel));\nexports.DefaultNodeModel = DefaultNodeModel;\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LabelModel_1 = __webpack_require__(26);\nvar DefaultLabelModel = /** @class */ (function (_super) {\n    __extends(DefaultLabelModel, _super);\n    function DefaultLabelModel() {\n        var _this = _super.call(this, \"default\") || this;\n        _this.offsetY = -23;\n        return _this;\n    }\n    DefaultLabelModel.prototype.setLabel = function (label) {\n        this.label = label;\n    };\n    return DefaultLabelModel;\n}(LabelModel_1.LabelModel));\nexports.DefaultLabelModel = DefaultLabelModel;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseModel_1 = __webpack_require__(5);\nvar LabelModel = /** @class */ (function (_super) {\n    __extends(LabelModel, _super);\n    function LabelModel(type, id) {\n        var _this = _super.call(this, type, id) || this;\n        _this.offsetX = 0;\n        _this.offsetY = 0;\n        return _this;\n    }\n    return LabelModel;\n}(BaseModel_1.BaseModel));\nexports.LabelModel = LabelModel;\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar PointModel_1 = __webpack_require__(7);\nvar Toolkit_1 = __webpack_require__(6);\nvar PathFinding_1 = __webpack_require__(16);\nvar _ = __webpack_require__(0);\nvar BaseWidget_1 = __webpack_require__(3);\nvar DefaultLinkWidget = /** @class */ (function (_super) {\n    __extends(DefaultLinkWidget, _super);\n    function DefaultLinkWidget(props) {\n        var _this = _super.call(this, \"srd-default-link\", props) || this;\n        _this.addPointToLink = function (event, index) {\n            if (!event.shiftKey &&\n                !_this.props.diagramEngine.isModelLocked(_this.props.link) &&\n                _this.props.link.points.length - 1 <= _this.props.diagramEngine.getMaxNumberPointsPerLink()) {\n                var point = new PointModel_1.PointModel(_this.props.link, _this.props.diagramEngine.getRelativeMousePoint(event));\n                point.setSelected(true);\n                _this.forceUpdate();\n                _this.props.link.addPoint(point, index);\n                _this.props.pointAdded(point, event);\n            }\n        };\n        _this.findPathAndRelativePositionToRenderLabel = function (index) {\n            // an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\n            var lengths = _this.refPaths.map(function (path) { return path.getTotalLength(); });\n            // calculate the point where we want to display the label\n            var labelPosition = lengths.reduce(function (previousValue, currentValue) { return previousValue + currentValue; }, 0) *\n                (index / (_this.props.link.labels.length + 1));\n            // find the path where the label will be rendered and calculate the relative position\n            var pathIndex = 0;\n            while (pathIndex < _this.refPaths.length) {\n                if (labelPosition - lengths[pathIndex] < 0) {\n                    return {\n                        path: _this.refPaths[pathIndex],\n                        position: labelPosition\n                    };\n                }\n                // keep searching\n                labelPosition -= lengths[pathIndex];\n                pathIndex++;\n            }\n        };\n        _this.calculateLabelPosition = function (label, index) {\n            if (!_this.refLabels[label.id]) {\n                // no label? nothing to do here\n                return;\n            }\n            var _a = _this.findPathAndRelativePositionToRenderLabel(index), path = _a.path, position = _a.position;\n            var labelDimensions = {\n                width: _this.refLabels[label.id].offsetWidth,\n                height: _this.refLabels[label.id].offsetHeight\n            };\n            var pathCentre = path.getPointAtLength(position);\n            var labelCoordinates = {\n                x: pathCentre.x - labelDimensions.width / 2 + label.offsetX,\n                y: pathCentre.y - labelDimensions.height / 2 + label.offsetY\n            };\n            _this.refLabels[label.id].setAttribute(\"style\", \"transform: translate(\" + labelCoordinates.x + \"px, \" + labelCoordinates.y + \"px);\");\n        };\n        _this.refLabels = {};\n        _this.refPaths = [];\n        _this.state = {\n            selected: false\n        };\n        if (props.diagramEngine.isSmartRoutingEnabled()) {\n            _this.pathFinding = new PathFinding_1.default(_this.props.diagramEngine);\n        }\n        return _this;\n    }\n    DefaultLinkWidget.prototype.calculateAllLabelPosition = function () {\n        var _this = this;\n        _.forEach(this.props.link.labels, function (label, index) {\n            _this.calculateLabelPosition(label, index + 1);\n        });\n    };\n    DefaultLinkWidget.prototype.componentDidUpdate = function () {\n        if (this.props.link.labels.length > 0) {\n            window.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n        }\n    };\n    DefaultLinkWidget.prototype.componentDidMount = function () {\n        if (this.props.link.labels.length > 0) {\n            window.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n        }\n    };\n    DefaultLinkWidget.prototype.generatePoint = function (pointIndex) {\n        var _this = this;\n        var x = this.props.link.points[pointIndex].x;\n        var y = this.props.link.points[pointIndex].y;\n        return (React.createElement(\"g\", { key: \"point-\" + this.props.link.points[pointIndex].id },\n            React.createElement(\"circle\", { cx: x, cy: y, r: 5, className: \"point \" +\n                    this.bem(\"__point\") +\n                    (this.props.link.points[pointIndex].isSelected() ? this.bem(\"--point-selected\") : \"\") }),\n            React.createElement(\"circle\", { onMouseLeave: function () {\n                    _this.setState({ selected: false });\n                }, onMouseEnter: function () {\n                    _this.setState({ selected: true });\n                }, \"data-id\": this.props.link.points[pointIndex].id, \"data-linkid\": this.props.link.id, cx: x, cy: y, r: 15, opacity: 0, className: \"point \" + this.bem(\"__point\") })));\n    };\n    DefaultLinkWidget.prototype.generateLabel = function (label) {\n        var _this = this;\n        var canvas = this.props.diagramEngine.canvas;\n        return (React.createElement(\"foreignObject\", { key: label.id, className: this.bem(\"__label\"), width: canvas.offsetWidth, height: canvas.offsetHeight },\n            React.createElement(\"div\", { ref: function (ref) { return (_this.refLabels[label.id] = ref); } }, this.props.diagramEngine\n                .getFactoryForLabel(label)\n                .generateReactWidget(this.props.diagramEngine, label))));\n    };\n    DefaultLinkWidget.prototype.generateLink = function (path, extraProps, id) {\n        var _this = this;\n        var props = this.props;\n        var Bottom = React.cloneElement(props.diagramEngine.getFactoryForLink(this.props.link).generateLinkSegment(this.props.link, this, this.state.selected || this.props.link.isSelected(), path), {\n            ref: function (ref) { return ref && _this.refPaths.push(ref); }\n        });\n        var Top = React.cloneElement(Bottom, __assign({}, extraProps, { strokeLinecap: \"round\", onMouseLeave: function () {\n                _this.setState({ selected: false });\n            }, onMouseEnter: function () {\n                _this.setState({ selected: true });\n            }, ref: null, \"data-linkid\": this.props.link.getID(), strokeOpacity: this.state.selected ? 0.1 : 0, strokeWidth: 20, onContextMenu: function () {\n                if (!_this.props.diagramEngine.isModelLocked(_this.props.link)) {\n                    event.preventDefault();\n                    _this.props.link.remove();\n                }\n            } }));\n        return (React.createElement(\"g\", { key: \"link-\" + id },\n            Bottom,\n            Top));\n    };\n    /**\n     * Smart routing is only applicable when all conditions below are true:\n     * - smart routing is set to true on the engine\n     * - current link is between two nodes (not between a node and an empty point)\n     * - no custom points exist along the line\n     */\n    DefaultLinkWidget.prototype.isSmartRoutingApplicable = function () {\n        var _a = this.props, diagramEngine = _a.diagramEngine, link = _a.link;\n        if (!diagramEngine.isSmartRoutingEnabled()) {\n            return false;\n        }\n        if (link.points.length !== 2) {\n            return false;\n        }\n        if (link.sourcePort === null || link.targetPort === null) {\n            return false;\n        }\n        return true;\n    };\n    DefaultLinkWidget.prototype.render = function () {\n        var _this = this;\n        var diagramEngine = this.props.diagramEngine;\n        if (!diagramEngine.nodesRendered) {\n            return null;\n        }\n        //ensure id is present for all points on the path\n        var points = this.props.link.points;\n        var paths = [];\n        if (this.isSmartRoutingApplicable()) {\n            // first step: calculate a direct path between the points being linked\n            var directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n            var routingMatrix = diagramEngine.getRoutingMatrix();\n            // now we need to extract, from the routing matrix, the very first walkable points\n            // so they can be used as origin and destination of the link to be created\n            var smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n            if (smartLink) {\n                var start = smartLink.start, end = smartLink.end, pathToStart = smartLink.pathToStart, pathToEnd = smartLink.pathToEnd;\n                // second step: calculate a path avoiding hitting other elements\n                var simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n                paths.push(\n                //smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n                this.generateLink(Toolkit_1.Toolkit.generateDynamicPath(simplifiedPath), {\n                    onMouseDown: function (event) {\n                        _this.addPointToLink(event, 1);\n                    }\n                }, \"0\"));\n            }\n        }\n        // true when smart routing was skipped or not enabled.\n        // See @link{#isSmartRoutingApplicable()}.\n        if (paths.length === 0) {\n            if (points.length === 2) {\n                //draw the smoothing\n                //if the points are too close, just draw a straight line\n                var margin = 50;\n                if (Math.abs(points[0].x - points[1].x) < 50) {\n                    margin = 5;\n                }\n                var pointLeft = points[0];\n                var pointRight = points[1];\n                //some defensive programming to make sure the smoothing is\n                //always in the right direction\n                if (pointLeft.x > pointRight.x) {\n                    pointLeft = points[1];\n                    pointRight = points[0];\n                }\n                paths.push(this.generateLink(Toolkit_1.Toolkit.generateCurvePath(pointLeft, pointRight, this.props.link.curvyness), {\n                    onMouseDown: function (event) {\n                        _this.addPointToLink(event, 1);\n                    }\n                }, \"0\"));\n                // draw the link as dangeling\n                if (this.props.link.targetPort === null) {\n                    paths.push(this.generatePoint(1));\n                }\n            }\n            else {\n                var _loop_1 = function (i_1) {\n                    paths.push(this_1.generateLink(Toolkit_1.Toolkit.generateLinePath(points[i_1], points[i_1 + 1]), {\n                        \"data-linkid\": this_1.props.link.id,\n                        \"data-point\": i_1,\n                        onMouseDown: function (event) {\n                            _this.addPointToLink(event, i_1 + 1);\n                        }\n                    }, i_1));\n                };\n                var this_1 = this;\n                //draw the multiple anchors and complex line instead\n                for (var i_1 = 0; i_1 < points.length - 1; i_1++) {\n                    _loop_1(i_1);\n                }\n                //render the circles\n                for (var i = 1; i < points.length - 1; i++) {\n                    paths.push(this.generatePoint(i));\n                }\n                if (this.props.link.targetPort === null) {\n                    paths.push(this.generatePoint(points.length - 1));\n                }\n            }\n        }\n        this.refPaths = [];\n        return (React.createElement(\"g\", __assign({}, this.getProps()),\n            paths,\n            _.map(this.props.link.labels, function (labelModel) {\n                return _this.generateLabel(labelModel);\n            })));\n    };\n    DefaultLinkWidget.defaultProps = {\n        color: \"black\",\n        width: 3,\n        link: null,\n        engine: null,\n        smooth: false,\n        diagramEngine: null\n    };\n    return DefaultLinkWidget;\n}(BaseWidget_1.BaseWidget));\nexports.DefaultLinkWidget = DefaultLinkWidget;\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar _ = __webpack_require__(0);\nvar DefaultPortLabelWidget_1 = __webpack_require__(29);\nvar BaseWidget_1 = __webpack_require__(3);\n/**\n * @author Dylan Vorster\n */\nvar DefaultNodeWidget = /** @class */ (function (_super) {\n    __extends(DefaultNodeWidget, _super);\n    function DefaultNodeWidget(props) {\n        var _this = _super.call(this, \"srd-default-node\", props) || this;\n        _this.state = {};\n        return _this;\n    }\n    DefaultNodeWidget.prototype.generatePort = function (port) {\n        return React.createElement(DefaultPortLabelWidget_1.DefaultPortLabel, { model: port, key: port.id });\n    };\n    DefaultNodeWidget.prototype.render = function () {\n        return (React.createElement(\"div\", __assign({}, this.getProps(), { style: { background: this.props.node.color } }),\n            React.createElement(\"div\", { className: this.bem(\"__title\") },\n                React.createElement(\"div\", { className: this.bem(\"__name\") }, this.props.node.name)),\n            React.createElement(\"div\", { className: this.bem(\"__ports\") },\n                React.createElement(\"div\", { className: this.bem(\"__in\") }, _.map(this.props.node.getInPorts(), this.generatePort.bind(this))),\n                React.createElement(\"div\", { className: this.bem(\"__out\") }, _.map(this.props.node.getOutPorts(), this.generatePort.bind(this))))));\n    };\n    return DefaultNodeWidget;\n}(BaseWidget_1.BaseWidget));\nexports.DefaultNodeWidget = DefaultNodeWidget;\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar PortWidget_1 = __webpack_require__(30);\nvar BaseWidget_1 = __webpack_require__(3);\n/**\n * @author Dylan Vorster\n */\nvar DefaultPortLabel = /** @class */ (function (_super) {\n    __extends(DefaultPortLabel, _super);\n    function DefaultPortLabel(props) {\n        return _super.call(this, \"srd-default-port\", props) || this;\n    }\n    DefaultPortLabel.prototype.getClassName = function () {\n        return _super.prototype.getClassName.call(this) + (this.props.model.in ? this.bem(\"--in\") : this.bem(\"--out\"));\n    };\n    DefaultPortLabel.prototype.render = function () {\n        var port = React.createElement(PortWidget_1.PortWidget, { node: this.props.model.getParent(), name: this.props.model.name });\n        var label = React.createElement(\"div\", { className: \"name\" }, this.props.model.label);\n        return (React.createElement(\"div\", __assign({}, this.getProps()),\n            this.props.model.in ? port : label,\n            this.props.model.in ? label : port));\n    };\n    return DefaultPortLabel;\n}(BaseWidget_1.BaseWidget));\nexports.DefaultPortLabel = DefaultPortLabel;\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar BaseWidget_1 = __webpack_require__(3);\n/**\n * @author Dylan Vorster\n */\nvar PortWidget = /** @class */ (function (_super) {\n    __extends(PortWidget, _super);\n    function PortWidget(props) {\n        var _this = _super.call(this, \"srd-port\", props) || this;\n        _this.state = {\n            selected: false\n        };\n        return _this;\n    }\n    PortWidget.prototype.getClassName = function () {\n        return \"port \" + _super.prototype.getClassName.call(this) + (this.state.selected ? this.bem(\"--selected\") : \"\");\n    };\n    PortWidget.prototype.render = function () {\n        var _this = this;\n        return (React.createElement(\"div\", __assign({}, this.getProps(), { onMouseEnter: function () {\n                _this.setState({ selected: true });\n            }, onMouseLeave: function () {\n                _this.setState({ selected: false });\n            }, \"data-name\": this.props.name, \"data-nodeid\": this.props.node.getID() })));\n    };\n    return PortWidget;\n}(BaseWidget_1.BaseWidget));\nexports.PortWidget = PortWidget;\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DefaultPortModel_1 = __webpack_require__(15);\nvar AbstractFactory_1 = __webpack_require__(10);\nvar DefaultPortFactory = /** @class */ (function (_super) {\n    __extends(DefaultPortFactory, _super);\n    function DefaultPortFactory() {\n        return _super.call(this, \"default\") || this;\n    }\n    DefaultPortFactory.prototype.getNewInstance = function (initialConfig) {\n        return new DefaultPortModel_1.DefaultPortModel(true, \"unknown\");\n    };\n    return DefaultPortFactory;\n}(AbstractFactory_1.PortFactory));\nexports.DefaultPortFactory = DefaultPortFactory;\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseAction = /** @class */ (function () {\n    function BaseAction(mouseX, mouseY) {\n        this.mouseX = mouseX;\n        this.mouseY = mouseY;\n        this.ms = new Date().getTime();\n    }\n    return BaseAction;\n}());\nexports.BaseAction = BaseAction;\nvar SelectingAction = /** @class */ (function (_super) {\n    __extends(SelectingAction, _super);\n    function SelectingAction(mouseX, mouseY) {\n        var _this = _super.call(this, mouseX, mouseY) || this;\n        _this.mouseX2 = mouseX;\n        _this.mouseY2 = mouseY;\n        return _this;\n    }\n    SelectingAction.prototype.getBoxDimensions = function () {\n        return {\n            left: this.mouseX2 > this.mouseX ? this.mouseX : this.mouseX2,\n            top: this.mouseY2 > this.mouseY ? this.mouseY : this.mouseY2,\n            width: Math.abs(this.mouseX2 - this.mouseX),\n            height: Math.abs(this.mouseY2 - this.mouseY),\n            right: this.mouseX2 < this.mouseX ? this.mouseX : this.mouseX2,\n            bottom: this.mouseY2 < this.mouseY ? this.mouseY : this.mouseY2\n        };\n    };\n    SelectingAction.prototype.containsElement = function (x, y, diagramModel) {\n        var z = diagramModel.getZoomLevel() / 100.0;\n        var dimensions = this.getBoxDimensions();\n        return (x * z + diagramModel.getOffsetX() > dimensions.left &&\n            x * z + diagramModel.getOffsetX() < dimensions.right &&\n            y * z + diagramModel.getOffsetY() > dimensions.top &&\n            y * z + diagramModel.getOffsetY() < dimensions.bottom);\n    };\n    return SelectingAction;\n}(BaseAction));\nexports.SelectingAction = SelectingAction;\nvar MoveCanvasAction = /** @class */ (function (_super) {\n    __extends(MoveCanvasAction, _super);\n    function MoveCanvasAction(mouseX, mouseY, diagramModel) {\n        var _this = _super.call(this, mouseX, mouseY) || this;\n        _this.initialOffsetX = diagramModel.getOffsetX();\n        _this.initialOffsetY = diagramModel.getOffsetY();\n        return _this;\n    }\n    return MoveCanvasAction;\n}(BaseAction));\nexports.MoveCanvasAction = MoveCanvasAction;\nvar MoveItemsAction = /** @class */ (function (_super) {\n    __extends(MoveItemsAction, _super);\n    function MoveItemsAction(mouseX, mouseY, diagramEngine) {\n        var _this = _super.call(this, mouseX, mouseY) || this;\n        _this.moved = false;\n        diagramEngine.enableRepaintEntities(diagramEngine.getDiagramModel().getSelectedItems());\n        var selectedItems = diagramEngine.getDiagramModel().getSelectedItems();\n        //dont allow items which are locked to move\n        selectedItems = selectedItems.filter(function (item) {\n            return !diagramEngine.isModelLocked(item);\n        });\n        _this.selectionModels = selectedItems.map(function (item) {\n            return {\n                model: item,\n                initialX: item.x,\n                initialY: item.y\n            };\n        });\n        return _this;\n    }\n    return MoveItemsAction;\n}(BaseAction));\nexports.MoveItemsAction = MoveItemsAction;\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar LinkWidget_1 = __webpack_require__(34);\nvar _ = __webpack_require__(0);\nvar BaseWidget_1 = __webpack_require__(3);\n/**\n * @author Dylan Vorster\n */\nvar LinkLayerWidget = /** @class */ (function (_super) {\n    __extends(LinkLayerWidget, _super);\n    function LinkLayerWidget(props) {\n        var _this = _super.call(this, \"srd-link-layer\", props) || this;\n        _this.state = {};\n        return _this;\n    }\n    LinkLayerWidget.prototype.render = function () {\n        var _this = this;\n        var diagramModel = this.props.diagramEngine.getDiagramModel();\n        return (React.createElement(\"svg\", __assign({}, this.getProps(), { style: {\n                transform: \"translate(\" +\n                    diagramModel.getOffsetX() +\n                    \"px,\" +\n                    diagramModel.getOffsetY() +\n                    \"px) scale(\" +\n                    diagramModel.getZoomLevel() / 100.0 +\n                    \")\"\n            } }), //only perform these actions when we have a diagram\n        this.props.diagramEngine.canvas &&\n            _.map(diagramModel.getLinks(), function (link) {\n                if (_this.props.diagramEngine.nodesRendered &&\n                    !_this.props.diagramEngine.linksThatHaveInitiallyRendered[link.id]) {\n                    if (link.sourcePort !== null) {\n                        try {\n                            var portCenter = _this.props.diagramEngine.getPortCenter(link.sourcePort);\n                            link.points[0].updateLocation(portCenter);\n                            var portCoords = _this.props.diagramEngine.getPortCoords(link.sourcePort);\n                            link.sourcePort.updateCoords(portCoords);\n                            _this.props.diagramEngine.linksThatHaveInitiallyRendered[link.id] = true;\n                        }\n                        catch (ex) { }\n                    }\n                    if (link.targetPort !== null) {\n                        try {\n                            var portCenter = _this.props.diagramEngine.getPortCenter(link.targetPort);\n                            _.last(link.points).updateLocation(portCenter);\n                            var portCoords = _this.props.diagramEngine.getPortCoords(link.targetPort);\n                            link.targetPort.updateCoords(portCoords);\n                            _this.props.diagramEngine.linksThatHaveInitiallyRendered[link.id] = true;\n                        }\n                        catch (ex) { }\n                    }\n                }\n                //generate links\n                var generatedLink = _this.props.diagramEngine.generateWidgetForLink(link);\n                if (!generatedLink) {\n                    console.log(\"no link generated for type: \" + link.getType());\n                    return null;\n                }\n                return (React.createElement(LinkWidget_1.LinkWidget, { key: link.getID(), link: link, diagramEngine: _this.props.diagramEngine }, React.cloneElement(generatedLink, {\n                    pointAdded: _this.props.pointAdded\n                })));\n            })));\n    };\n    return LinkLayerWidget;\n}(BaseWidget_1.BaseWidget));\nexports.LinkLayerWidget = LinkLayerWidget;\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseWidget_1 = __webpack_require__(3);\n/**\n * @author Dylan Vorster\n */\nvar LinkWidget = /** @class */ (function (_super) {\n    __extends(LinkWidget, _super);\n    function LinkWidget(props) {\n        var _this = _super.call(this, \"srd-link\", props) || this;\n        _this.state = {};\n        return _this;\n    }\n    LinkWidget.prototype.shouldComponentUpdate = function () {\n        return this.props.diagramEngine.canEntityRepaint(this.props.link);\n    };\n    LinkWidget.prototype.render = function () {\n        return this.props.children;\n    };\n    return LinkWidget;\n}(BaseWidget_1.BaseWidget));\nexports.LinkWidget = LinkWidget;\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar _ = __webpack_require__(0);\nvar NodeWidget_1 = __webpack_require__(36);\nvar BaseWidget_1 = __webpack_require__(3);\nvar NodeLayerWidget = /** @class */ (function (_super) {\n    __extends(NodeLayerWidget, _super);\n    function NodeLayerWidget(props) {\n        var _this = _super.call(this, \"srd-node-layer\", props) || this;\n        _this.updateNodeDimensions = function () {\n            if (!_this.props.diagramEngine.nodesRendered) {\n                var diagramModel = _this.props.diagramEngine.getDiagramModel();\n                _.map(diagramModel.getNodes(), function (node) {\n                    node.updateDimensions(_this.props.diagramEngine.getNodeDimensions(node));\n                });\n            }\n        };\n        _this.state = {};\n        return _this;\n    }\n    NodeLayerWidget.prototype.componentDidUpdate = function () {\n        this.updateNodeDimensions();\n        this.props.diagramEngine.nodesRendered = true;\n    };\n    NodeLayerWidget.prototype.render = function () {\n        var _this = this;\n        var diagramModel = this.props.diagramEngine.getDiagramModel();\n        return (React.createElement(\"div\", __assign({}, this.getProps(), { style: {\n                transform: \"translate(\" +\n                    diagramModel.getOffsetX() +\n                    \"px,\" +\n                    diagramModel.getOffsetY() +\n                    \"px) scale(\" +\n                    diagramModel.getZoomLevel() / 100.0 +\n                    \")\"\n            } }), _.map(diagramModel.getNodes(), function (node) {\n            return React.createElement(NodeWidget_1.NodeWidget, {\n                diagramEngine: _this.props.diagramEngine,\n                key: node.id,\n                node: node\n            }, _this.props.diagramEngine.generateWidgetForNode(node));\n        })));\n    };\n    return NodeLayerWidget;\n}(BaseWidget_1.BaseWidget));\nexports.NodeLayerWidget = NodeLayerWidget;\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar BaseWidget_1 = __webpack_require__(3);\n/**\n * @author Dylan Vorster\n */\nvar NodeWidget = /** @class */ (function (_super) {\n    __extends(NodeWidget, _super);\n    function NodeWidget(props) {\n        var _this = _super.call(this, \"srd-node\", props) || this;\n        _this.state = {};\n        return _this;\n    }\n    NodeWidget.prototype.shouldComponentUpdate = function () {\n        return this.props.diagramEngine.canEntityRepaint(this.props.node);\n    };\n    NodeWidget.prototype.getClassName = function () {\n        return \"node \" + _super.prototype.getClassName.call(this) + (this.props.node.isSelected() ? this.bem(\"--selected\") : \"\");\n    };\n    NodeWidget.prototype.render = function () {\n        return (React.createElement(\"div\", __assign({}, this.getProps(), { \"data-nodeid\": this.props.node.id, style: {\n                top: this.props.node.y,\n                left: this.props.node.x\n            } }), this.props.children));\n    };\n    return NodeWidget;\n}(BaseWidget_1.BaseWidget));\nexports.NodeWidget = NodeWidget;\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar matches = __webpack_require__(38)\r\n\r\nmodule.exports = function (element, selector, checkYoSelf) {\r\n  var parent = checkYoSelf ? element : element.parentNode\r\n\r\n  while (parent && parent !== document) {\r\n    if (matches(parent, selector)) return parent;\r\n    parent = parent.parentNode\r\n  }\r\n}\r\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\n\r\n/**\r\n * Element prototype.\r\n */\r\n\r\nvar proto = Element.prototype;\r\n\r\n/**\r\n * Vendor function.\r\n */\r\n\r\nvar vendor = proto.matchesSelector\r\n  || proto.webkitMatchesSelector\r\n  || proto.mozMatchesSelector\r\n  || proto.msMatchesSelector\r\n  || proto.oMatchesSelector;\r\n\r\n/**\r\n * Expose `match()`.\r\n */\r\n\r\nmodule.exports = match;\r\n\r\n/**\r\n * Match `el` to `selector`.\r\n *\r\n * @param {Element} el\r\n * @param {String} selector\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nfunction match(el, selector) {\r\n  if (vendor) return vendor.call(el, selector);\r\n  var nodes = el.parentNode.querySelectorAll(selector);\r\n  for (var i = 0; i < nodes.length; ++i) {\r\n    if (nodes[i] == el) return true;\r\n  }\r\n  return false;\r\n}\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(40);\r\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\r\n    'Heap'                      : __webpack_require__(13),\r\n    'Node'                      : __webpack_require__(17),\r\n    'Grid'                      : __webpack_require__(43),\r\n    'Util'                      : __webpack_require__(4),\r\n    'DiagonalMovement'          : __webpack_require__(1),\r\n    'Heuristic'                 : __webpack_require__(8),\r\n    'AStarFinder'               : __webpack_require__(18),\r\n    'BestFirstFinder'           : __webpack_require__(44),\r\n    'BreadthFirstFinder'        : __webpack_require__(45),\r\n    'DijkstraFinder'            : __webpack_require__(46),\r\n    'BiAStarFinder'             : __webpack_require__(19),\r\n    'BiBestFirstFinder'         : __webpack_require__(47),\r\n    'BiBreadthFirstFinder'      : __webpack_require__(48),\r\n    'BiDijkstraFinder'          : __webpack_require__(49),\r\n    'IDAStarFinder'             : __webpack_require__(50),\r\n    'JumpPointFinder'           : __webpack_require__(51),\r\n};\r\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)(module)))\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Node = __webpack_require__(17);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // \r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // \r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // \r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // \r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // \r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar AStarFinder = __webpack_require__(18);\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(4);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar AStarFinder = __webpack_require__(18);\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BiAStarFinder = __webpack_require__(19);\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(4);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BiAStarFinder = __webpack_require__(19);\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util       = __webpack_require__(4);\r\nvar Heuristic  = __webpack_require__(8);\r\nvar Node       = __webpack_require__(17);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = __webpack_require__(1);\r\nvar JPFNeverMoveDiagonally = __webpack_require__(52);\r\nvar JPFAlwaysMoveDiagonally = __webpack_require__(53);\r\nvar JPFMoveDiagonallyIfNoObstacles = __webpack_require__(54);\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = __webpack_require__(55);\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = __webpack_require__(14);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = __webpack_require__(14);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = __webpack_require__(14);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = __webpack_require__(14);\r\nvar DiagonalMovement = __webpack_require__(1);\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nvar Path = function Path(init) {\n  var _instructions = init || [];\n\n  var push = function push(arr, el) {\n    var copy = arr.slice(0, arr.length);\n    copy.push(el);\n    return copy;\n  };\n\n  var areEqualPoints = function areEqualPoints(_ref, _ref3) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    var a1 = _ref2[0];\n    var b1 = _ref2[1];\n\n    var _ref32 = _slicedToArray(_ref3, 2);\n\n    var a2 = _ref32[0];\n    var b2 = _ref32[1];\n    return a1 === a2 && b1 === b2;\n  };\n\n  var trimZeros = function trimZeros(string, char) {\n    var l = string.length;\n    while (string.charAt(l - 1) === '0') {\n      l = l - 1;\n    }\n    if (string.charAt(l - 1) === '.') {\n      l = l - 1;\n    }\n    return string.substr(0, l);\n  };\n\n  var round = function round(number, digits) {\n    var str = number.toFixed(digits);\n    return trimZeros(str);\n  };\n\n  var printInstrunction = function printInstrunction(_ref4) {\n    var command = _ref4.command;\n    var params = _ref4.params;\n\n    var numbers = params.map(function (param) {\n      return round(param, 6);\n    });\n    return command + ' ' + numbers.join(' ');\n  };\n\n  var point = function point(_ref5, _ref6) {\n    var command = _ref5.command;\n    var params = _ref5.params;\n\n    var _ref62 = _slicedToArray(_ref6, 2);\n\n    var prevX = _ref62[0];\n    var prevY = _ref62[1];\n\n    switch (command) {\n      case 'M':\n        return [params[0], params[1]];\n      case 'L':\n        return [params[0], params[1]];\n      case 'H':\n        return [params[0], prevY];\n      case 'V':\n        return [prevX, params[0]];\n      case 'Z':\n        return null;\n      case 'C':\n        return [params[4], params[5]];\n      case 'S':\n        return [params[2], params[3]];\n      case 'Q':\n        return [params[2], params[3]];\n      case 'T':\n        return [params[0], params[1]];\n      case 'A':\n        return [params[5], params[6]];\n    }\n  };\n\n  var verbosify = function verbosify(keys, f) {\n    return function (a) {\n      var args = typeof a === 'object' ? keys.map(function (k) {\n        return a[k];\n      }) : arguments;\n      return f.apply(null, args);\n    };\n  };\n\n  var plus = function plus(instruction) {\n    return Path(push(_instructions, instruction));\n  };\n\n  return {\n    moveto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'M',\n        params: [x, y]\n      });\n    }),\n    lineto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'L',\n        params: [x, y]\n      });\n    }),\n    hlineto: verbosify(['x'], function (x) {\n      return plus({\n        command: 'H',\n        params: [x]\n      });\n    }),\n    vlineto: verbosify(['y'], function (y) {\n      return plus({\n        command: 'V',\n        params: [y]\n      });\n    }),\n    closepath: function closepath() {\n      return plus({\n        command: 'Z',\n        params: []\n      });\n    },\n    curveto: verbosify(['x1', 'y1', 'x2', 'y2', 'x', 'y'], function (x1, y1, x2, y2, x, y) {\n      return plus({\n        command: 'C',\n        params: [x1, y1, x2, y2, x, y]\n      });\n    }),\n    smoothcurveto: verbosify(['x2', 'y2', 'x', 'y'], function (x2, y2, x, y) {\n      return plus({\n        command: 'S',\n        params: [x2, y2, x, y]\n      });\n    }),\n    qcurveto: verbosify(['x1', 'y1', 'x', 'y'], function (x1, y1, x, y) {\n      return plus({\n        command: 'Q',\n        params: [x1, y1, x, y]\n      });\n    }),\n    smoothqcurveto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'T',\n        params: [x, y]\n      });\n    }),\n    arc: verbosify(['rx', 'ry', 'xrot', 'largeArcFlag', 'sweepFlag', 'x', 'y'], function (rx, ry, xrot, largeArcFlag, sweepFlag, x, y) {\n      return plus({\n        command: 'A',\n        params: [rx, ry, xrot, largeArcFlag, sweepFlag, x, y]\n      });\n    }),\n    print: function print() {\n      return _instructions.map(printInstrunction).join(' ');\n    },\n    toString: function toString() {\n      return undefined.print();\n    },\n    points: function points() {\n      var ps = [];\n      var prev = [0, 0];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _instructions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var instruction = _step.value;\n\n          var p = point(instruction, prev);\n          prev = p;\n          if (p) {\n            ps.push(p);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return ps;\n    },\n    instructions: function instructions() {\n      return _instructions.slice(0, _instructions.length);\n    },\n    connect: function connect(path) {\n      var ps = this.points();\n      var last = ps[ps.length - 1];\n      var first = path.points()[0];\n      var newInstructions = path.instructions().slice(1);\n      if (!areEqualPoints(last, first)) {\n        newInstructions.unshift({\n          command: \"L\",\n          params: first\n        });\n      }\n      return Path(this.instructions().concat(newInstructions));\n    }\n  };\n};\n\nexports['default'] = function () {\n  return Path();\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar DefaultLinkWidget_1 = __webpack_require__(27);\nvar AbstractFactory_1 = __webpack_require__(10);\nvar DefaultLinkModel_1 = __webpack_require__(20);\n/**\n * @author Dylan Vorster\n */\nvar DefaultLinkFactory = /** @class */ (function (_super) {\n    __extends(DefaultLinkFactory, _super);\n    function DefaultLinkFactory() {\n        return _super.call(this, \"default\") || this;\n    }\n    DefaultLinkFactory.prototype.generateReactWidget = function (diagramEngine, link) {\n        return React.createElement(DefaultLinkWidget_1.DefaultLinkWidget, {\n            link: link,\n            diagramEngine: diagramEngine\n        });\n    };\n    DefaultLinkFactory.prototype.getNewInstance = function (initialConfig) {\n        return new DefaultLinkModel_1.DefaultLinkModel();\n    };\n    DefaultLinkFactory.prototype.generateLinkSegment = function (model, widget, selected, path) {\n        return (React.createElement(\"path\", { className: selected ? widget.bem(\"--path-selected\") : \"\", strokeWidth: model.width, stroke: model.color, d: path }));\n    };\n    return DefaultLinkFactory;\n}(AbstractFactory_1.LinkFactory));\nexports.DefaultLinkFactory = DefaultLinkFactory;\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DefaultNodeModel_1 = __webpack_require__(24);\nvar React = __webpack_require__(2);\nvar DefaultNodeWidget_1 = __webpack_require__(28);\nvar AbstractFactory_1 = __webpack_require__(10);\n/**\n * @author Dylan Vorster\n */\nvar DefaultNodeFactory = /** @class */ (function (_super) {\n    __extends(DefaultNodeFactory, _super);\n    function DefaultNodeFactory() {\n        return _super.call(this, \"default\") || this;\n    }\n    DefaultNodeFactory.prototype.generateReactWidget = function (diagramEngine, node) {\n        return React.createElement(DefaultNodeWidget_1.DefaultNodeWidget, {\n            node: node,\n            diagramEngine: diagramEngine\n        });\n    };\n    DefaultNodeFactory.prototype.getNewInstance = function (initialConfig) {\n        return new DefaultNodeModel_1.DefaultNodeModel();\n    };\n    return DefaultNodeFactory;\n}(AbstractFactory_1.NodeFactory));\nexports.DefaultNodeFactory = DefaultNodeFactory;\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseEntity_1 = __webpack_require__(12);\nvar DiagramModel_1 = __webpack_require__(22);\nvar _ = __webpack_require__(0);\nvar NodeModel_1 = __webpack_require__(9);\nvar PointModel_1 = __webpack_require__(7);\nvar main_1 = __webpack_require__(23);\nvar PathFinding_1 = __webpack_require__(16);\nvar DefaultPortFactory_1 = __webpack_require__(31);\nvar DefaultLabelFactory_1 = __webpack_require__(60);\nvar Toolkit_1 = __webpack_require__(6);\n/**\n * Passed as a parameter to the DiagramWidget\n */\nvar DiagramEngine = /** @class */ (function (_super) {\n    __extends(DiagramEngine, _super);\n    function DiagramEngine() {\n        var _this = _super.call(this) || this;\n        // calculated only when smart routing is active\n        _this.canvasMatrix = [];\n        _this.routingMatrix = [];\n        // used when at least one element has negative coordinates\n        _this.hAdjustmentFactor = 0;\n        _this.vAdjustmentFactor = 0;\n        /**\n         * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n         * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n         */\n        _this.calculateMatrixDimensions = function () {\n            var allNodesCoords = _.values(_this.diagramModel.nodes).map(function (item) { return ({\n                x: item.x,\n                width: item.width,\n                y: item.y,\n                height: item.height\n            }); });\n            var allLinks = _.values(_this.diagramModel.links);\n            var allPortsCoords = _.flatMap(allLinks.map(function (link) { return [link.sourcePort, link.targetPort]; }))\n                .filter(function (port) { return port !== null; })\n                .map(function (item) { return ({\n                x: item.x,\n                width: item.width,\n                y: item.y,\n                height: item.height\n            }); });\n            var allPointsCoords = _.flatMap(allLinks.map(function (link) { return link.points; })).map(function (item) { return ({\n                // points don't have width/height, so let's just use 0\n                x: item.x,\n                width: 0,\n                y: item.y,\n                height: 0\n            }); });\n            var canvas = _this.canvas;\n            var minX = Math.floor(Math.min(_.minBy(_.concat(allNodesCoords, allPortsCoords, allPointsCoords), function (item) { return item.x; }).x, 0) /\n                PathFinding_1.ROUTING_SCALING_FACTOR) * PathFinding_1.ROUTING_SCALING_FACTOR;\n            var maxXElement = _.maxBy(_.concat(allNodesCoords, allPortsCoords, allPointsCoords), function (item) { return item.x + item.width; });\n            var maxX = Math.max(maxXElement.x + maxXElement.width, canvas.offsetWidth);\n            var minY = Math.floor(Math.min(_.minBy(_.concat(allNodesCoords, allPortsCoords, allPointsCoords), function (item) { return item.y; }).y, 0) /\n                PathFinding_1.ROUTING_SCALING_FACTOR) * PathFinding_1.ROUTING_SCALING_FACTOR;\n            var maxYElement = _.maxBy(_.concat(allNodesCoords, allPortsCoords, allPointsCoords), function (item) { return item.y + item.height; });\n            var maxY = Math.max(maxYElement.y + maxYElement.height, canvas.offsetHeight);\n            return {\n                width: Math.ceil(Math.abs(minX) + maxX),\n                hAdjustmentFactor: Math.abs(minX) / PathFinding_1.ROUTING_SCALING_FACTOR + 1,\n                height: Math.ceil(Math.abs(minY) + maxY),\n                vAdjustmentFactor: Math.abs(minY) / PathFinding_1.ROUTING_SCALING_FACTOR + 1\n            };\n        };\n        /**\n         * Updates (by reference) where nodes will be drawn on the matrix passed in.\n         */\n        _this.markNodes = function (matrix) {\n            _.values(_this.diagramModel.nodes).forEach(function (node) {\n                var startX = Math.floor(node.x / PathFinding_1.ROUTING_SCALING_FACTOR);\n                var endX = Math.ceil((node.x + node.width) / PathFinding_1.ROUTING_SCALING_FACTOR);\n                var startY = Math.floor(node.y / PathFinding_1.ROUTING_SCALING_FACTOR);\n                var endY = Math.ceil((node.y + node.height) / PathFinding_1.ROUTING_SCALING_FACTOR);\n                for (var x = startX - 1; x <= endX + 1; x++) {\n                    for (var y = startY - 1; y < endY + 1; y++) {\n                        _this.markMatrixPoint(matrix, _this.translateRoutingX(x), _this.translateRoutingY(y));\n                    }\n                }\n            });\n        };\n        /**\n         * Updates (by reference) where ports will be drawn on the matrix passed in.\n         */\n        _this.markPorts = function (matrix) {\n            var allElements = _.flatMap(_.values(_this.diagramModel.links).map(function (link) { return [].concat(link.sourcePort, link.targetPort); }));\n            allElements.filter(function (port) { return port !== null; }).forEach(function (port) {\n                var startX = Math.floor(port.x / PathFinding_1.ROUTING_SCALING_FACTOR);\n                var endX = Math.ceil((port.x + port.width) / PathFinding_1.ROUTING_SCALING_FACTOR);\n                var startY = Math.floor(port.y / PathFinding_1.ROUTING_SCALING_FACTOR);\n                var endY = Math.ceil((port.y + port.height) / PathFinding_1.ROUTING_SCALING_FACTOR);\n                for (var x = startX - 1; x <= endX + 1; x++) {\n                    for (var y = startY - 1; y < endY + 1; y++) {\n                        _this.markMatrixPoint(matrix, _this.translateRoutingX(x), _this.translateRoutingY(y));\n                    }\n                }\n            });\n        };\n        _this.markMatrixPoint = function (matrix, x, y) {\n            if (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n                matrix[y][x] = 1;\n            }\n        };\n        _this.diagramModel = new DiagramModel_1.DiagramModel();\n        _this.nodeFactories = {};\n        _this.linkFactories = {};\n        _this.portFactories = {};\n        _this.labelFactories = {};\n        _this.canvas = null;\n        _this.paintableWidgets = null;\n        _this.linksThatHaveInitiallyRendered = {};\n        if (Toolkit_1.Toolkit.TESTING) {\n            Toolkit_1.Toolkit.TESTING_UID = 0;\n            //pop it onto the window so our E2E helpers can find it\n            if (window) {\n                window[\"diagram_instance\"] = _this;\n            }\n        }\n        return _this;\n    }\n    DiagramEngine.prototype.installDefaultFactories = function () {\n        this.registerNodeFactory(new main_1.DefaultNodeFactory());\n        this.registerLinkFactory(new main_1.DefaultLinkFactory());\n        this.registerPortFactory(new DefaultPortFactory_1.DefaultPortFactory());\n        this.registerLabelFactory(new DefaultLabelFactory_1.DefaultLabelFactory());\n    };\n    DiagramEngine.prototype.repaintCanvas = function () {\n        this.iterateListeners(function (listener) {\n            listener.repaintCanvas && listener.repaintCanvas();\n        });\n    };\n    DiagramEngine.prototype.clearRepaintEntities = function () {\n        this.paintableWidgets = null;\n    };\n    DiagramEngine.prototype.enableRepaintEntities = function (entities) {\n        var _this = this;\n        this.paintableWidgets = {};\n        entities.forEach(function (entity) {\n            //if a node is requested to repaint, add all of its links\n            if (entity instanceof NodeModel_1.NodeModel) {\n                _.forEach(entity.getPorts(), function (port) {\n                    _.forEach(port.getLinks(), function (link) {\n                        _this.paintableWidgets[link.getID()] = true;\n                    });\n                });\n            }\n            if (entity instanceof PointModel_1.PointModel) {\n                _this.paintableWidgets[entity.getLink().getID()] = true;\n            }\n            _this.paintableWidgets[entity.getID()] = true;\n        });\n    };\n    /**\n     * Checks to see if a model is locked by running through\n     * its parents to see if they are locked first\n     */\n    DiagramEngine.prototype.isModelLocked = function (model) {\n        //always check the diagram model\n        if (this.diagramModel.isLocked()) {\n            return true;\n        }\n        return model.isLocked();\n    };\n    DiagramEngine.prototype.recalculatePortsVisually = function () {\n        this.nodesRendered = false;\n        this.linksThatHaveInitiallyRendered = {};\n    };\n    DiagramEngine.prototype.canEntityRepaint = function (baseModel) {\n        //no rules applied, allow repaint\n        if (this.paintableWidgets === null) {\n            return true;\n        }\n        return this.paintableWidgets[baseModel.getID()] !== undefined;\n    };\n    DiagramEngine.prototype.setCanvas = function (canvas) {\n        this.canvas = canvas;\n    };\n    DiagramEngine.prototype.setDiagramModel = function (model) {\n        this.diagramModel = model;\n        this.recalculatePortsVisually();\n    };\n    DiagramEngine.prototype.getDiagramModel = function () {\n        return this.diagramModel;\n    };\n    //!-------------- FACTORIES ------------\n    DiagramEngine.prototype.getNodeFactories = function () {\n        return this.nodeFactories;\n    };\n    DiagramEngine.prototype.getLinkFactories = function () {\n        return this.linkFactories;\n    };\n    DiagramEngine.prototype.getLabelFactories = function () {\n        return this.labelFactories;\n    };\n    DiagramEngine.prototype.registerLabelFactory = function (factory) {\n        this.labelFactories[factory.getType()] = factory;\n        this.iterateListeners(function (listener) {\n            if (listener.labelFactoriesUpdated) {\n                listener.labelFactoriesUpdated();\n            }\n        });\n    };\n    DiagramEngine.prototype.registerPortFactory = function (factory) {\n        this.portFactories[factory.getType()] = factory;\n        this.iterateListeners(function (listener) {\n            if (listener.portFactoriesUpdated) {\n                listener.portFactoriesUpdated();\n            }\n        });\n    };\n    DiagramEngine.prototype.registerNodeFactory = function (factory) {\n        this.nodeFactories[factory.getType()] = factory;\n        this.iterateListeners(function (listener) {\n            if (listener.nodeFactoriesUpdated) {\n                listener.nodeFactoriesUpdated();\n            }\n        });\n    };\n    DiagramEngine.prototype.registerLinkFactory = function (factory) {\n        this.linkFactories[factory.getType()] = factory;\n        this.iterateListeners(function (listener) {\n            if (listener.linkFactoriesUpdated) {\n                listener.linkFactoriesUpdated();\n            }\n        });\n    };\n    DiagramEngine.prototype.getPortFactory = function (type) {\n        if (this.portFactories[type]) {\n            return this.portFactories[type];\n        }\n        console.log(\"cannot find factory for port of type: [\" + type + \"]\");\n        return null;\n    };\n    DiagramEngine.prototype.getNodeFactory = function (type) {\n        if (this.nodeFactories[type]) {\n            return this.nodeFactories[type];\n        }\n        console.log(\"cannot find factory for node of type: [\" + type + \"]\");\n        return null;\n    };\n    DiagramEngine.prototype.getLinkFactory = function (type) {\n        if (this.linkFactories[type]) {\n            return this.linkFactories[type];\n        }\n        console.log(\"cannot find factory for link of type: [\" + type + \"]\");\n        return null;\n    };\n    DiagramEngine.prototype.getLabelFactory = function (type) {\n        if (this.labelFactories[type]) {\n            return this.labelFactories[type];\n        }\n        console.log(\"cannot find factory for label of type: [\" + type + \"]\");\n        return null;\n    };\n    DiagramEngine.prototype.getFactoryForNode = function (node) {\n        return this.getNodeFactory(node.getType());\n    };\n    DiagramEngine.prototype.getFactoryForLink = function (link) {\n        return this.getLinkFactory(link.getType());\n    };\n    DiagramEngine.prototype.getFactoryForLabel = function (label) {\n        return this.getLabelFactory(label.getType());\n    };\n    DiagramEngine.prototype.generateWidgetForLink = function (link) {\n        var linkFactory = this.getFactoryForLink(link);\n        if (!linkFactory) {\n            throw new Error(\"Cannot find link factory for link: \" + link.getType());\n        }\n        return linkFactory.generateReactWidget(this, link);\n    };\n    DiagramEngine.prototype.generateWidgetForNode = function (node) {\n        var nodeFactory = this.getFactoryForNode(node);\n        if (!nodeFactory) {\n            throw new Error(\"Cannot find widget factory for node: \" + node.getType());\n        }\n        return nodeFactory.generateReactWidget(this, node);\n    };\n    DiagramEngine.prototype.getRelativeMousePoint = function (event) {\n        var point = this.getRelativePoint(event.clientX, event.clientY);\n        return {\n            x: (point.x - this.diagramModel.getOffsetX()) / (this.diagramModel.getZoomLevel() / 100.0),\n            y: (point.y - this.diagramModel.getOffsetY()) / (this.diagramModel.getZoomLevel() / 100.0)\n        };\n    };\n    DiagramEngine.prototype.getRelativePoint = function (x, y) {\n        var canvasRect = this.canvas.getBoundingClientRect();\n        return { x: x - canvasRect.left, y: y - canvasRect.top };\n    };\n    DiagramEngine.prototype.getNodeElement = function (node) {\n        var selector = this.canvas.querySelector('.node[data-nodeid=\"' + node.getID() + '\"]');\n        if (selector === null) {\n            throw new Error(\"Cannot find Node element with nodeID: [\" + node.getID() + \"]\");\n        }\n        return selector;\n    };\n    DiagramEngine.prototype.getNodePortElement = function (port) {\n        var selector = this.canvas.querySelector('.port[data-name=\"' + port.getName() + '\"][data-nodeid=\"' + port.getParent().getID() + '\"]');\n        if (selector === null) {\n            throw new Error(\"Cannot find Node Port element with nodeID: [\" +\n                port.getParent().getID() +\n                \"] and name: [\" +\n                port.getName() +\n                \"]\");\n        }\n        return selector;\n    };\n    DiagramEngine.prototype.getPortCenter = function (port) {\n        var sourceElement = this.getNodePortElement(port);\n        var sourceRect = sourceElement.getBoundingClientRect();\n        var rel = this.getRelativePoint(sourceRect.left, sourceRect.top);\n        return {\n            x: sourceElement.offsetWidth / 2 +\n                (rel.x - this.diagramModel.getOffsetX()) / (this.diagramModel.getZoomLevel() / 100.0),\n            y: sourceElement.offsetHeight / 2 +\n                (rel.y - this.diagramModel.getOffsetY()) / (this.diagramModel.getZoomLevel() / 100.0)\n        };\n    };\n    /**\n     * Calculate rectangular coordinates of the port passed in.\n     */\n    DiagramEngine.prototype.getPortCoords = function (port) {\n        var sourceElement = this.getNodePortElement(port);\n        var sourceRect = sourceElement.getBoundingClientRect();\n        var canvasRect = this.canvas.getBoundingClientRect();\n        return {\n            x: (sourceRect.x - this.diagramModel.getOffsetX()) / (this.diagramModel.getZoomLevel() / 100.0) -\n                canvasRect.left,\n            y: (sourceRect.y - this.diagramModel.getOffsetY()) / (this.diagramModel.getZoomLevel() / 100.0) -\n                canvasRect.top,\n            width: sourceRect.width,\n            height: sourceRect.height\n        };\n    };\n    /**\n     * Determine the width and height of the node passed in.\n     * It currently assumes nodes have a rectangular shape, can be overriden for customised shapes.\n     */\n    DiagramEngine.prototype.getNodeDimensions = function (node) {\n        if (!this.canvas) {\n            return {\n                width: 0,\n                height: 0\n            };\n        }\n        var nodeElement = this.getNodeElement(node);\n        var nodeRect = nodeElement.getBoundingClientRect();\n        return {\n            width: nodeRect.width,\n            height: nodeRect.height\n        };\n    };\n    DiagramEngine.prototype.getMaxNumberPointsPerLink = function () {\n        return this.maxNumberPointsPerLink;\n    };\n    DiagramEngine.prototype.setMaxNumberPointsPerLink = function (max) {\n        this.maxNumberPointsPerLink = max;\n    };\n    DiagramEngine.prototype.isSmartRoutingEnabled = function () {\n        return !!this.smartRouting;\n    };\n    DiagramEngine.prototype.setSmartRoutingStatus = function (status) {\n        this.smartRouting = status;\n    };\n    /**\n     * A representation of the canvas in the following format:\n     *\n     * +-----------------+\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * +-----------------+\n     *\n     * In which all walkable points are marked by zeros.\n     * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n     */\n    DiagramEngine.prototype.getCanvasMatrix = function () {\n        if (this.canvasMatrix.length === 0) {\n            this.calculateCanvasMatrix();\n        }\n        return this.canvasMatrix;\n    };\n    DiagramEngine.prototype.calculateCanvasMatrix = function () {\n        var _a = this.calculateMatrixDimensions(), canvasWidth = _a.width, hAdjustmentFactor = _a.hAdjustmentFactor, canvasHeight = _a.height, vAdjustmentFactor = _a.vAdjustmentFactor;\n        this.hAdjustmentFactor = hAdjustmentFactor;\n        this.vAdjustmentFactor = vAdjustmentFactor;\n        var matrixWidth = Math.ceil(canvasWidth / PathFinding_1.ROUTING_SCALING_FACTOR);\n        var matrixHeight = Math.ceil(canvasHeight / PathFinding_1.ROUTING_SCALING_FACTOR);\n        this.canvasMatrix = _.range(0, matrixHeight).map(function () {\n            return new Array(matrixWidth).fill(0);\n        });\n    };\n    /**\n     * A representation of the canvas in the following format:\n     *\n     * +-----------------+\n     * | 0 0 1 1 0 0 0 0 |\n     * | 0 0 1 1 0 0 1 1 |\n     * | 0 0 0 0 0 0 1 1 |\n     * | 1 1 0 0 0 0 0 0 |\n     * | 1 1 0 0 0 0 0 0 |\n     * +-----------------+\n     *\n     * In which all points blocked by a node (and its ports) are\n     * marked as 1; points were there is nothing (ie, free) receive 0.\n     */\n    DiagramEngine.prototype.getRoutingMatrix = function () {\n        if (this.routingMatrix.length === 0) {\n            this.calculateRoutingMatrix();\n        }\n        return this.routingMatrix;\n    };\n    DiagramEngine.prototype.calculateRoutingMatrix = function () {\n        var matrix = _.cloneDeep(this.getCanvasMatrix());\n        // nodes need to be marked as blocked points\n        this.markNodes(matrix);\n        // same thing for ports\n        this.markPorts(matrix);\n        this.routingMatrix = matrix;\n    };\n    /**\n     * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n     * We use the functions below to translate back and forth between these coordinates, relying on the\n     * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n     */\n    DiagramEngine.prototype.translateRoutingX = function (x, reverse) {\n        if (reverse === void 0) { reverse = false; }\n        return x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n    };\n    DiagramEngine.prototype.translateRoutingY = function (y, reverse) {\n        if (reverse === void 0) { reverse = false; }\n        return y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n    };\n    DiagramEngine.prototype.zoomToFit = function () {\n        var xFactor = this.canvas.clientWidth / this.canvas.scrollWidth;\n        var yFactor = this.canvas.clientHeight / this.canvas.scrollHeight;\n        var zoomFactor = xFactor < yFactor ? xFactor : yFactor;\n        this.diagramModel.setZoomLevel(this.diagramModel.getZoomLevel() * zoomFactor);\n        this.diagramModel.setOffset(0, 0);\n        this.repaintCanvas();\n    };\n    return DiagramEngine;\n}(BaseEntity_1.BaseEntity));\nexports.DiagramEngine = DiagramEngine;\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar AbstractFactory_1 = __webpack_require__(10);\nvar DefaultLabelModel_1 = __webpack_require__(25);\nvar DefaultLabelWidget_1 = __webpack_require__(61);\n/**\n * @author Dylan Vorster\n */\nvar DefaultLabelFactory = /** @class */ (function (_super) {\n    __extends(DefaultLabelFactory, _super);\n    function DefaultLabelFactory() {\n        return _super.call(this, \"default\") || this;\n    }\n    DefaultLabelFactory.prototype.generateReactWidget = function (diagramEngine, label) {\n        return React.createElement(DefaultLabelWidget_1.DefaultLabelWidget, { model: label });\n    };\n    DefaultLabelFactory.prototype.getNewInstance = function (initialConfig) {\n        return new DefaultLabelModel_1.DefaultLabelModel();\n    };\n    return DefaultLabelFactory;\n}(AbstractFactory_1.LabelFactory));\nexports.DefaultLabelFactory = DefaultLabelFactory;\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar BaseWidget_1 = __webpack_require__(3);\nvar DefaultLabelWidget = /** @class */ (function (_super) {\n    __extends(DefaultLabelWidget, _super);\n    function DefaultLabelWidget(props) {\n        return _super.call(this, \"srd-default-label\", props) || this;\n    }\n    DefaultLabelWidget.prototype.render = function () {\n        return React.createElement(\"div\", __assign({}, this.getProps()), this.props.model.label);\n    };\n    return DefaultLabelWidget;\n}(BaseWidget_1.BaseWidget));\nexports.DefaultLabelWidget = DefaultLabelWidget;\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __webpack_require__(2);\nvar _ = __webpack_require__(0);\nvar LinkLayerWidget_1 = __webpack_require__(33);\nvar NodeLayerWidget_1 = __webpack_require__(35);\nvar Toolkit_1 = __webpack_require__(6);\nvar CanvasActions_1 = __webpack_require__(32);\nvar NodeModel_1 = __webpack_require__(9);\nvar PointModel_1 = __webpack_require__(7);\nvar PortModel_1 = __webpack_require__(11);\nvar BaseWidget_1 = __webpack_require__(3);\n/**\n * @author Dylan Vorster\n */\nvar DiagramWidget = /** @class */ (function (_super) {\n    __extends(DiagramWidget, _super);\n    function DiagramWidget(props) {\n        var _this = _super.call(this, \"srd-diagram\", props) || this;\n        _this.onMouseMove = _this.onMouseMove.bind(_this);\n        _this.onMouseUp = _this.onMouseUp.bind(_this);\n        _this.state = {\n            action: null,\n            wasMoved: false,\n            renderedNodes: false,\n            windowListener: null,\n            diagramEngineListener: null,\n            document: null\n        };\n        return _this;\n    }\n    DiagramWidget.prototype.componentWillUnmount = function () {\n        this.props.diagramEngine.removeListener(this.state.diagramEngineListener);\n        this.props.diagramEngine.setCanvas(null);\n        window.removeEventListener(\"keyup\", this.onKeyUpPointer);\n        window.removeEventListener(\"mouseUp\", this.onMouseUp);\n        window.removeEventListener(\"mouseMove\", this.onMouseMove);\n    };\n    DiagramWidget.prototype.componentWillReceiveProps = function (nextProps) {\n        var _this = this;\n        if (this.props.diagramEngine !== nextProps.diagramEngine) {\n            this.props.diagramEngine.removeListener(this.state.diagramEngineListener);\n            var diagramEngineListener = nextProps.diagramEngine.addListener({\n                repaintCanvas: function () { return _this.forceUpdate(); }\n            });\n            this.setState({ diagramEngineListener: diagramEngineListener });\n        }\n    };\n    DiagramWidget.prototype.componentWillUpdate = function (nextProps) {\n        if (this.props.diagramEngine.diagramModel.id !== nextProps.diagramEngine.diagramModel.id) {\n            this.setState({ renderedNodes: false });\n            nextProps.diagramEngine.diagramModel.rendered = true;\n        }\n        if (!nextProps.diagramEngine.diagramModel.rendered) {\n            this.setState({ renderedNodes: false });\n            nextProps.diagramEngine.diagramModel.rendered = true;\n        }\n    };\n    DiagramWidget.prototype.componentDidUpdate = function () {\n        if (!this.state.renderedNodes) {\n            this.setState({\n                renderedNodes: true\n            });\n        }\n    };\n    DiagramWidget.prototype.componentDidMount = function () {\n        var _this = this;\n        this.onKeyUpPointer = this.onKeyUp.bind(this);\n        //add a keyboard listener\n        this.setState({\n            document: document,\n            renderedNodes: true,\n            diagramEngineListener: this.props.diagramEngine.addListener({\n                repaintCanvas: function () {\n                    _this.forceUpdate();\n                }\n            })\n        });\n        window.addEventListener(\"keyup\", this.onKeyUpPointer, false);\n        // dont focus the window when in test mode - jsdom fails\n        if (true) {\n            window.focus();\n        }\n    };\n    /**\n     * Gets a model and element under the mouse cursor\n     */\n    DiagramWidget.prototype.getMouseElement = function (event) {\n        var target = event.target;\n        var diagramModel = this.props.diagramEngine.diagramModel;\n        //is it a port\n        var element = Toolkit_1.Toolkit.closest(target, \".port[data-name]\");\n        if (element) {\n            var nodeElement = Toolkit_1.Toolkit.closest(target, \".node[data-nodeid]\");\n            return {\n                model: diagramModel\n                    .getNode(nodeElement.getAttribute(\"data-nodeid\"))\n                    .getPort(element.getAttribute(\"data-name\")),\n                element: element\n            };\n        }\n        //look for a point\n        element = Toolkit_1.Toolkit.closest(target, \".point[data-id]\");\n        if (element) {\n            return {\n                model: diagramModel\n                    .getLink(element.getAttribute(\"data-linkid\"))\n                    .getPointModel(element.getAttribute(\"data-id\")),\n                element: element\n            };\n        }\n        //look for a link\n        element = Toolkit_1.Toolkit.closest(target, \"[data-linkid]\");\n        if (element) {\n            return {\n                model: diagramModel.getLink(element.getAttribute(\"data-linkid\")),\n                element: element\n            };\n        }\n        //look for a node\n        element = Toolkit_1.Toolkit.closest(target, \".node[data-nodeid]\");\n        if (element) {\n            return {\n                model: diagramModel.getNode(element.getAttribute(\"data-nodeid\")),\n                element: element\n            };\n        }\n        return null;\n    };\n    DiagramWidget.prototype.fireAction = function () {\n        if (this.state.action && this.props.actionStillFiring) {\n            this.props.actionStillFiring(this.state.action);\n        }\n    };\n    DiagramWidget.prototype.stopFiringAction = function (shouldSkipEvent) {\n        if (this.props.actionStoppedFiring && !shouldSkipEvent) {\n            this.props.actionStoppedFiring(this.state.action);\n        }\n        this.setState({ action: null });\n    };\n    DiagramWidget.prototype.startFiringAction = function (action) {\n        var setState = true;\n        if (this.props.actionStartedFiring) {\n            setState = this.props.actionStartedFiring(action);\n        }\n        if (setState) {\n            this.setState({ action: action });\n        }\n    };\n    DiagramWidget.prototype.onMouseMove = function (event) {\n        var _this = this;\n        var diagramEngine = this.props.diagramEngine;\n        var diagramModel = diagramEngine.getDiagramModel();\n        //select items so draw a bounding box\n        if (this.state.action instanceof CanvasActions_1.SelectingAction) {\n            var relative = diagramEngine.getRelativePoint(event.clientX, event.clientY);\n            _.forEach(diagramModel.getNodes(), function (node) {\n                if (_this.state.action.containsElement(node.x, node.y, diagramModel)) {\n                    node.setSelected(true);\n                }\n            });\n            _.forEach(diagramModel.getLinks(), function (link) {\n                var allSelected = true;\n                _.forEach(link.points, function (point) {\n                    if (_this.state.action.containsElement(point.x, point.y, diagramModel)) {\n                        point.setSelected(true);\n                    }\n                    else {\n                        allSelected = false;\n                    }\n                });\n                if (allSelected) {\n                    link.setSelected(true);\n                }\n            });\n            this.state.action.mouseX2 = relative.x;\n            this.state.action.mouseY2 = relative.y;\n            this.fireAction();\n            this.setState({ action: this.state.action });\n            return;\n        }\n        else if (this.state.action instanceof CanvasActions_1.MoveItemsAction) {\n            var amountX_1 = event.clientX - this.state.action.mouseX;\n            var amountY_1 = event.clientY - this.state.action.mouseY;\n            var amountZoom_1 = diagramModel.getZoomLevel() / 100;\n            _.forEach(this.state.action.selectionModels, function (model) {\n                // in this case we need to also work out the relative grid position\n                if (model.model instanceof NodeModel_1.NodeModel ||\n                    (model.model instanceof PointModel_1.PointModel && !model.model.isConnectedToPort())) {\n                    model.model.x = diagramModel.getGridPosition(model.initialX + amountX_1 / amountZoom_1);\n                    model.model.y = diagramModel.getGridPosition(model.initialY + amountY_1 / amountZoom_1);\n                    // update port coordinates as well\n                    if (model.model instanceof NodeModel_1.NodeModel) {\n                        _.forEach(model.model.getPorts(), function (port) {\n                            var portCoords = _this.props.diagramEngine.getPortCoords(port);\n                            port.updateCoords(portCoords);\n                        });\n                    }\n                    if (diagramEngine.isSmartRoutingEnabled()) {\n                        diagramEngine.calculateRoutingMatrix();\n                    }\n                }\n                else if (model.model instanceof PointModel_1.PointModel) {\n                    // we want points that are connected to ports, to not neccesarilly snap to grid\n                    // this stuff needs to be pixel perfect, dont touch it\n                    model.model.x = model.initialX + diagramModel.getGridPosition(amountX_1 / amountZoom_1);\n                    model.model.y = model.initialY + diagramModel.getGridPosition(amountY_1 / amountZoom_1);\n                }\n            });\n            if (diagramEngine.isSmartRoutingEnabled()) {\n                diagramEngine.calculateCanvasMatrix();\n            }\n            this.fireAction();\n            if (!this.state.wasMoved) {\n                this.setState({ wasMoved: true });\n            }\n            else {\n                this.forceUpdate();\n            }\n        }\n        else if (this.state.action instanceof CanvasActions_1.MoveCanvasAction) {\n            //translate the actual canvas\n            if (this.props.allowCanvasTranslation) {\n                diagramModel.setOffset(this.state.action.initialOffsetX + (event.clientX - this.state.action.mouseX), this.state.action.initialOffsetY + (event.clientY - this.state.action.mouseY));\n                this.fireAction();\n                this.forceUpdate();\n            }\n        }\n    };\n    DiagramWidget.prototype.onKeyUp = function (event) {\n        var _this = this;\n        //delete all selected\n        if (this.props.deleteKeys.indexOf(event.keyCode) !== -1) {\n            _.forEach(this.props.diagramEngine.getDiagramModel().getSelectedItems(), function (element) {\n                //only delete items which are not locked\n                if (!_this.props.diagramEngine.isModelLocked(element)) {\n                    element.remove();\n                }\n            });\n            this.forceUpdate();\n        }\n    };\n    DiagramWidget.prototype.onMouseUp = function (event) {\n        var _this = this;\n        var diagramEngine = this.props.diagramEngine;\n        //are we going to connect a link to something?\n        if (this.state.action instanceof CanvasActions_1.MoveItemsAction) {\n            var element = this.getMouseElement(event);\n            var linkConnected = false;\n            _.forEach(this.state.action.selectionModels, function (model) {\n                //only care about points connecting to things\n                if (!(model.model instanceof PointModel_1.PointModel)) {\n                    return;\n                }\n                if (element && element.model instanceof PortModel_1.PortModel && !diagramEngine.isModelLocked(element.model)) {\n                    linkConnected = true;\n                    var link = model.model.getLink();\n                    if (link.getTargetPort() !== null) {\n                        //if this was a valid link already and we are adding a node in the middle, create 2 links from the original\n                        if (link.getTargetPort() !== element.model && link.getSourcePort() !== element.model) {\n                            var targetPort = link.getTargetPort();\n                            var newLink = link.clone({});\n                            newLink.setSourcePort(element.model);\n                            newLink.setTargetPort(targetPort);\n                            link.setTargetPort(element.model);\n                            targetPort.removeLink(link);\n                            newLink.removePointsBefore(newLink.getPoints()[link.getPointIndex(model.model)]);\n                            link.removePointsAfter(model.model);\n                            diagramEngine.getDiagramModel().addLink(newLink);\n                            //if we are connecting to the same target or source, remove tweener points\n                        }\n                        else if (link.getTargetPort() === element.model) {\n                            link.removePointsAfter(model.model);\n                        }\n                        else if (link.getSourcePort() === element.model) {\n                            link.removePointsBefore(model.model);\n                        }\n                    }\n                    else {\n                        link.setTargetPort(element.model);\n                    }\n                    delete _this.props.diagramEngine.linksThatHaveInitiallyRendered[link.getID()];\n                }\n                //if we moved a NodeModel and allowLooseLinks is false, we know that any links involved were valid\n                if ((!_this.props.allowLooseLinks && element.model instanceof NodeModel_1.NodeModel) || !_this.state.wasMoved) {\n                    linkConnected = true;\n                }\n            });\n            //do we want to allow loose links on the diagram model or not\n            if (!linkConnected && !this.props.allowLooseLinks) {\n                _.forEach(this.state.action.selectionModels, function (model) {\n                    //only care about points connecting to things\n                    if (!(model.model instanceof PointModel_1.PointModel)) {\n                        return;\n                    }\n                    var link = model.model.getLink();\n                    if (link.isLastPoint(model.model)) {\n                        link.remove();\n                    }\n                });\n            }\n            //remove any invalid links\n            _.forEach(this.state.action.selectionModels, function (model) {\n                //only care about points connecting to things\n                if (!(model.model instanceof PointModel_1.PointModel)) {\n                    return;\n                }\n                var link = model.model.getLink();\n                var sourcePort = link.getSourcePort();\n                var targetPort = link.getTargetPort();\n                if (sourcePort !== null && targetPort !== null) {\n                    if (!sourcePort.canLinkToPort(targetPort)) {\n                        //link not allowed\n                        link.remove();\n                    }\n                    else if (_.some(_.values(targetPort.getLinks()), function (l) {\n                        return l !== link && (l.getSourcePort() === sourcePort || l.getTargetPort() === sourcePort);\n                    })) {\n                        //link is a duplicate\n                        link.remove();\n                    }\n                }\n            });\n            diagramEngine.clearRepaintEntities();\n            this.stopFiringAction(!this.state.wasMoved);\n        }\n        else {\n            diagramEngine.clearRepaintEntities();\n            this.stopFiringAction();\n        }\n        this.state.document.removeEventListener(\"mousemove\", this.onMouseMove);\n        this.state.document.removeEventListener(\"mouseup\", this.onMouseUp);\n    };\n    DiagramWidget.prototype.drawSelectionBox = function () {\n        var dimensions = this.state.action.getBoxDimensions();\n        return (React.createElement(\"div\", { className: this.bem(\"__selector\"), style: {\n                top: dimensions.top,\n                left: dimensions.left,\n                width: dimensions.width,\n                height: dimensions.height\n            } }));\n    };\n    DiagramWidget.prototype.render = function () {\n        var _this = this;\n        var diagramEngine = this.props.diagramEngine;\n        diagramEngine.setMaxNumberPointsPerLink(this.props.maxNumberPointsPerLink);\n        diagramEngine.setSmartRoutingStatus(this.props.smartRouting);\n        var diagramModel = diagramEngine.getDiagramModel();\n        return (React.createElement(\"div\", __assign({}, this.getProps(), { ref: function (ref) {\n                if (ref) {\n                    _this.props.diagramEngine.setCanvas(ref);\n                }\n            }, onWheel: function (event) {\n                if (_this.props.allowCanvasZoom) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    var oldZoomFactor = diagramModel.getZoomLevel() / 100;\n                    var scrollDelta = _this.props.inverseZoom ? -event.deltaY : event.deltaY;\n                    //check if it is pinch gesture\n                    if (event.ctrlKey && scrollDelta % 1 !== 0) {\n                        /*Chrome and Firefox sends wheel event with deltaY that\n                            have fractional part, also `ctrlKey` prop of the event is true\n                            though ctrl isn't pressed\n                        */\n                        scrollDelta /= 3;\n                    }\n                    else {\n                        scrollDelta /= 60;\n                    }\n                    if (diagramModel.getZoomLevel() + scrollDelta > 10) {\n                        diagramModel.setZoomLevel(diagramModel.getZoomLevel() + scrollDelta);\n                    }\n                    var zoomFactor = diagramModel.getZoomLevel() / 100;\n                    var boundingRect = event.currentTarget.getBoundingClientRect();\n                    var clientWidth = boundingRect.width;\n                    var clientHeight = boundingRect.height;\n                    // compute difference between rect before and after scroll\n                    var widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n                    var heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n                    // compute mouse coords relative to canvas\n                    var clientX = event.clientX - boundingRect.left;\n                    var clientY = event.clientY - boundingRect.top;\n                    // compute width and height increment factor\n                    var xFactor = (clientX - diagramModel.getOffsetX()) / oldZoomFactor / clientWidth;\n                    var yFactor = (clientY - diagramModel.getOffsetY()) / oldZoomFactor / clientHeight;\n                    diagramModel.setOffset(diagramModel.getOffsetX() - widthDiff * xFactor, diagramModel.getOffsetY() - heightDiff * yFactor);\n                    diagramEngine.enableRepaintEntities([]);\n                    _this.forceUpdate();\n                }\n            }, onMouseDown: function (event) {\n                _this.setState(__assign({}, _this.state, { wasMoved: false }));\n                diagramEngine.clearRepaintEntities();\n                var model = _this.getMouseElement(event);\n                //the canvas was selected\n                if (model === null) {\n                    //is it a multiple selection\n                    if (event.shiftKey) {\n                        var relative = diagramEngine.getRelativePoint(event.clientX, event.clientY);\n                        _this.startFiringAction(new CanvasActions_1.SelectingAction(relative.x, relative.y));\n                    }\n                    else {\n                        //its a drag the canvas event\n                        diagramModel.clearSelection();\n                        _this.startFiringAction(new CanvasActions_1.MoveCanvasAction(event.clientX, event.clientY, diagramModel));\n                    }\n                }\n                else if (model.model instanceof PortModel_1.PortModel) {\n                    //its a port element, we want to drag a link\n                    if (!_this.props.diagramEngine.isModelLocked(model.model)) {\n                        var relative = diagramEngine.getRelativeMousePoint(event);\n                        var sourcePort = model.model;\n                        var link = sourcePort.createLinkModel();\n                        link.setSourcePort(sourcePort);\n                        if (link) {\n                            link.removeMiddlePoints();\n                            if (link.getSourcePort() !== sourcePort) {\n                                link.setSourcePort(sourcePort);\n                            }\n                            link.setTargetPort(null);\n                            link.getFirstPoint().updateLocation(relative);\n                            link.getLastPoint().updateLocation(relative);\n                            diagramModel.clearSelection();\n                            link.getLastPoint().setSelected(true);\n                            diagramModel.addLink(link);\n                            _this.startFiringAction(new CanvasActions_1.MoveItemsAction(event.clientX, event.clientY, diagramEngine));\n                        }\n                    }\n                    else {\n                        diagramModel.clearSelection();\n                    }\n                }\n                else {\n                    //its some or other element, probably want to move it\n                    if (!event.shiftKey && !model.model.isSelected()) {\n                        diagramModel.clearSelection();\n                    }\n                    model.model.setSelected(true);\n                    _this.startFiringAction(new CanvasActions_1.MoveItemsAction(event.clientX, event.clientY, diagramEngine));\n                }\n                _this.state.document.addEventListener(\"mousemove\", _this.onMouseMove);\n                _this.state.document.addEventListener(\"mouseup\", _this.onMouseUp);\n            } }),\n            this.state.renderedNodes && (React.createElement(LinkLayerWidget_1.LinkLayerWidget, { diagramEngine: diagramEngine, pointAdded: function (point, event) {\n                    _this.state.document.addEventListener(\"mousemove\", _this.onMouseMove);\n                    _this.state.document.addEventListener(\"mouseup\", _this.onMouseUp);\n                    event.stopPropagation();\n                    diagramModel.clearSelection(point);\n                    _this.setState({\n                        action: new CanvasActions_1.MoveItemsAction(event.clientX, event.clientY, diagramEngine)\n                    });\n                } })),\n            React.createElement(NodeLayerWidget_1.NodeLayerWidget, { diagramEngine: diagramEngine }),\n            this.state.action instanceof CanvasActions_1.SelectingAction && this.drawSelectionBox()));\n    };\n    DiagramWidget.defaultProps = {\n        diagramEngine: null,\n        allowLooseLinks: true,\n        allowCanvasTranslation: true,\n        allowCanvasZoom: true,\n        inverseZoom: false,\n        maxNumberPointsPerLink: Infinity,\n        smartRouting: false,\n        deleteKeys: [46, 8]\n    };\n    return DiagramWidget;\n}(BaseWidget_1.BaseWidget));\nexports.DiagramWidget = DiagramWidget;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// main.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 23);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap beff17714b3976b8bb9b","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"_\",\"root\":\"_\"}\n// module id = 0\n// module chunks = 0","var DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/core/DiagonalMovement.js\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 2\n// module chunks = 0","import * as React from \"react\";\nimport * as _ from \"lodash\";\n\nexport interface BaseWidgetProps {\n\t/**\n\t * Override the base class name\n\t */\n\tbaseClass?: string;\n\t/**\n\t * append additional classes\n\t */\n\tclassName?: string;\n\n\t/**\n\t * Additional props to add\n\t */\n\textraProps?: any;\n}\n\nexport class BaseWidget<P extends BaseWidgetProps = BaseWidgetProps, S = any> extends React.Component<P, S> {\n\tclassName: string;\n\n\tconstructor(name: string, props: P) {\n\t\tsuper(props);\n\t\tthis.className = name;\n\t}\n\n\tbem(selector: string): string {\n\t\treturn (this.props.baseClass || this.className) + selector + \" \";\n\t}\n\n\tgetClassName(): string {\n\t\treturn (\n\t\t\t(this.props.baseClass || this.className) + \" \" + (this.props.className ? this.props.className + \" \" : \"\")\n\t\t);\n\t}\n\n\tgetProps(): any {\n\t\treturn {\n\t\t\t...((this.props.extraProps as any) || {}),\n\t\t\tclassName: this.getClassName()\n\t\t};\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/BaseWidget.tsx","/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/core/Util.js\n// module id = 4\n// module chunks = 0","import { BaseEntity, BaseListener } from \"../BaseEntity\";\nimport * as _ from \"lodash\";\nimport { BaseEvent } from \"../BaseEntity\";\nimport { DiagramEngine } from \"../DiagramEngine\";\n\nexport interface BaseModelListener extends BaseListener {\n\tselectionChanged?(event: BaseEvent<BaseModel> & { isSelected: boolean }): void;\n\n\tentityRemoved?(event: BaseEvent<BaseModel>): void;\n}\n\n/**\n * @author Dylan Vorster\n */\nexport class BaseModel<\n\tX extends BaseEntity = BaseEntity,\n\tT extends BaseModelListener = BaseModelListener\n> extends BaseEntity<BaseModelListener> {\n\ttype: string;\n\tselected: boolean;\n\tparent: X;\n\n\tconstructor(type?: string, id?: string) {\n\t\tsuper(id);\n\t\tthis.type = type;\n\t\tthis.selected = false;\n\t}\n\n\tpublic getParent(): X {\n\t\treturn this.parent;\n\t}\n\n\tpublic setParent(parent: X) {\n\t\tthis.parent = parent;\n\t}\n\n\tpublic getSelectedEntities(): BaseModel<any, T>[] {\n\t\tif (this.isSelected()) {\n\t\t\treturn [this];\n\t\t}\n\t\treturn [];\n\t}\n\n\tpublic deSerialize(ob, engine: DiagramEngine) {\n\t\tsuper.deSerialize(ob, engine);\n\t\tthis.type = ob.type;\n\t\tthis.selected = ob.selected;\n\t}\n\n\tpublic serialize() {\n\t\treturn _.merge(super.serialize(), {\n\t\t\ttype: this.type,\n\t\t\tselected: this.selected\n\t\t});\n\t}\n\n\tpublic getType(): string {\n\t\treturn this.type;\n\t}\n\n\tpublic getID(): string {\n\t\treturn this.id;\n\t}\n\n\tpublic isSelected(): boolean {\n\t\treturn this.selected;\n\t}\n\n\tpublic setSelected(selected: boolean = true) {\n\t\tthis.selected = selected;\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tif (listener.selectionChanged) {\n\t\t\t\tlistener.selectionChanged({ ...event, isSelected: selected });\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic remove() {\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tif (listener.entityRemoved) {\n\t\t\t\tlistener.entityRemoved(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/models/BaseModel.ts","import closest = require(\"closest\");\nimport { PointModel } from \"./models/PointModel\";\nimport { ROUTING_SCALING_FACTOR } from \"./routing/PathFinding\";\nimport * as Path from \"paths-js/path\";\n/**\n * @author Dylan Vorster\n */\nexport class Toolkit {\n\tstatic TESTING: boolean = false;\n\tstatic TESTING_UID = 0;\n\n\t/**\n\t * Generats a unique ID (thanks Stack overflow :3)\n\t * @returns {String}\n\t */\n\tpublic static UID(): string {\n\t\tif (Toolkit.TESTING) {\n\t\t\tToolkit.TESTING_UID++;\n\t\t\treturn \"\" + Toolkit.TESTING_UID;\n\t\t}\n\t\treturn \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n\t\t\tvar r = (Math.random() * 16) | 0,\n\t\t\t\tv = c == \"x\" ? r : (r & 0x3) | 0x8;\n\t\t\treturn v.toString(16);\n\t\t});\n\t}\n\n\t/**\n\t * Finds the closest element as a polyfill\n\t *\n\t * @param  {Element} element  [description]\n\t * @param  {string}  selector [description]\n\t */\n\tpublic static closest(element: Element, selector: string) {\n\t\tif (document.body.closest) {\n\t\t\treturn element.closest(selector);\n\t\t}\n\t\treturn closest(element, selector);\n\t}\n\n\tpublic static generateLinePath(firstPoint: PointModel, lastPoint: PointModel): string {\n\t\treturn `M${firstPoint.x},${firstPoint.y} L ${lastPoint.x},${lastPoint.y}`;\n\t}\n\n\tpublic static generateCurvePath(firstPoint: PointModel, lastPoint: PointModel, curvy: number = 0): string {\n\t\treturn `M${firstPoint.x},${firstPoint.y} C ${firstPoint.x + curvy},${firstPoint.y} ${lastPoint.x + -curvy},${\n\t\t\tlastPoint.y\n\t\t} ${lastPoint.x},${lastPoint.y}`;\n\t}\n\n\tpublic static generateDynamicPath(pathCoords: number[][]) {\n\t\tlet path = Path();\n\t\tpath = path.moveto(pathCoords[0][0] * ROUTING_SCALING_FACTOR, pathCoords[0][1] * ROUTING_SCALING_FACTOR);\n\t\tpathCoords.slice(1).forEach(coords => {\n\t\t\tpath = path.lineto(coords[0] * ROUTING_SCALING_FACTOR, coords[1] * ROUTING_SCALING_FACTOR);\n\t\t});\n\t\treturn path.print();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Toolkit.ts","import { BaseModel, BaseModelListener } from \"./BaseModel\";\nimport { LinkModel } from \"./LinkModel\";\nimport * as _ from \"lodash\";\nimport { DiagramEngine } from \"../DiagramEngine\";\n\nexport class PointModel extends BaseModel<LinkModel, BaseModelListener> {\n\tx: number;\n\ty: number;\n\n\tconstructor(link: LinkModel, points: { x: number; y: number }) {\n\t\tsuper();\n\t\tthis.x = points.x;\n\t\tthis.y = points.y;\n\t\tthis.parent = link;\n\t}\n\n\tgetSelectedEntities() {\n\t\tif (super.isSelected() && !this.isConnectedToPort()) {\n\t\t\treturn [this];\n\t\t}\n\t\treturn [];\n\t}\n\n\tisConnectedToPort(): boolean {\n\t\treturn this.parent.getPortForPoint(this) !== null;\n\t}\n\n\tgetLink(): LinkModel {\n\t\treturn this.getParent();\n\t}\n\n\tdeSerialize(ob, engine: DiagramEngine) {\n\t\tsuper.deSerialize(ob, engine);\n\t\tthis.x = ob.x;\n\t\tthis.y = ob.y;\n\t}\n\n\tserialize() {\n\t\treturn _.merge(super.serialize(), {\n\t\t\tx: this.x,\n\t\t\ty: this.y\n\t\t});\n\t}\n\n\tremove() {\n\t\t//clear references\n\t\tif (this.parent) {\n\t\t\tthis.parent.removePoint(this);\n\t\t}\n\t\tsuper.remove();\n\t}\n\n\tupdateLocation(points: { x: number; y: number }) {\n\t\tthis.x = points.x;\n\t\tthis.y = points.y;\n\t}\n\n\tgetX(): number {\n\t\treturn this.x;\n\t}\n\n\tgetY(): number {\n\t\treturn this.y;\n\t}\n\n\tisLocked() {\n\t\treturn super.isLocked() || this.getParent().isLocked();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/models/PointModel.ts","/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/core/Heuristic.js\n// module id = 8\n// module chunks = 0","import { BaseModel, BaseModelListener } from \"./BaseModel\";\nimport { PortModel } from \"./PortModel\";\nimport * as _ from \"lodash\";\nimport { DiagramEngine } from \"../DiagramEngine\";\nimport { DiagramModel } from \"./DiagramModel\";\n\nexport class NodeModel extends BaseModel<DiagramModel, BaseModelListener> {\n\tx: number;\n\ty: number;\n\textras: any;\n\tports: { [s: string]: PortModel };\n\n\t// calculated post rendering so routing can be done correctly\n\twidth: number;\n\theight: number;\n\n\tconstructor(nodeType: string = \"default\", id?: string) {\n\t\tsuper(nodeType, id);\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tthis.extras = {};\n\t\tthis.ports = {};\n\t}\n\n\tsetPosition(x, y) {\n\t\t//store position\n\t\tlet oldX = this.x;\n\t\tlet oldY = this.y;\n\t\tfor (let port in this.ports) {\n\t\t\t_.forEach(this.ports[port].getLinks(), link => {\n\t\t\t\tlet point = link.getPointForPort(this.ports[port]);\n\t\t\t\tpoint.x = point.x + x - oldX;\n\t\t\t\tpoint.y = point.y + y - oldY;\n\t\t\t});\n\t\t}\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tgetSelectedEntities() {\n\t\tlet entities = super.getSelectedEntities();\n\n\t\t// add the points of each link that are selected here\n\t\tif (this.isSelected()) {\n\t\t\tfor (let portName in this.ports) {\n\t\t\t\tentities = entities.concat(\n\t\t\t\t\t_.map(this.ports[portName].getLinks(), link => {\n\t\t\t\t\t\treturn link.getPointForPort(this.ports[portName]);\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn entities;\n\t}\n\n\tdeSerialize(ob, engine: DiagramEngine) {\n\t\tsuper.deSerialize(ob, engine);\n\t\tthis.x = ob.x;\n\t\tthis.y = ob.y;\n\t\tthis.extras = ob.extras;\n\n\t\t//deserialize ports\n\t\t_.forEach(ob.ports, (port: any) => {\n\t\t\tlet portOb = engine.getPortFactory(port.type).getNewInstance();\n\t\t\tportOb.deSerialize(port, engine);\n\t\t\tthis.addPort(portOb);\n\t\t});\n\t}\n\n\tserialize() {\n\t\treturn _.merge(super.serialize(), {\n\t\t\tx: this.x,\n\t\t\ty: this.y,\n\t\t\textras: this.extras,\n\t\t\tports: _.map(this.ports, port => {\n\t\t\t\treturn port.serialize();\n\t\t\t})\n\t\t});\n\t}\n\n\tdoClone(lookupTable = {}, clone) {\n\t\t// also clone the ports\n\t\tclone.ports = {};\n\t\t_.values(this.ports).forEach(port => {\n\t\t\tclone.addPort(port.clone(lookupTable));\n\t\t});\n\t}\n\n\tremove() {\n\t\tsuper.remove();\n\t\tfor (var i in this.ports) {\n\t\t\t_.forEach(this.ports[i].getLinks(), link => {\n\t\t\t\tlink.remove();\n\t\t\t});\n\t\t}\n\t}\n\n\tgetPortFromID(id): PortModel | null {\n\t\tfor (var i in this.ports) {\n\t\t\tif (this.ports[i].id === id) {\n\t\t\t\treturn this.ports[i];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetPort(name: string): PortModel | null {\n\t\treturn this.ports[name];\n\t}\n\n\tgetPorts(): { [s: string]: PortModel } {\n\t\treturn this.ports;\n\t}\n\n\tremovePort(port: PortModel) {\n\t\t//clear the parent node reference\n\t\tif (this.ports[port.name]) {\n\t\t\tthis.ports[port.name].setParent(null);\n\t\t\tdelete this.ports[port.name];\n\t\t}\n\t}\n\n\taddPort<T extends PortModel>(port: T): T {\n\t\tport.setParent(this);\n\t\tthis.ports[port.name] = port;\n\t\treturn port;\n\t}\n\n\tupdateDimensions({ width, height }: { width: number; height: number }) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/models/NodeModel.ts","import { BaseModel } from \"./models/BaseModel\";\nimport { NodeModel } from \"./models/NodeModel\";\nimport { LinkModel } from \"./models/LinkModel\";\nimport { DiagramEngine } from \"./DiagramEngine\";\nimport { PortModel } from \"./models/PortModel\";\nimport { PointModel } from \"./models/PointModel\";\nimport { LabelModel } from \"./models/LabelModel\";\n\nexport abstract class AbstractFactory<T extends BaseModel> {\n\ttype: string;\n\n\tconstructor(name: string) {\n\t\tthis.type = name;\n\t}\n\n\tgetType(): string {\n\t\treturn this.type;\n\t}\n\n\tabstract getNewInstance(initialConfig?: any): T;\n}\n\nexport abstract class NodeFactory<T extends NodeModel = NodeModel> extends AbstractFactory<T> {\n\tabstract generateReactWidget(diagramEngine: DiagramEngine, node: T): JSX.Element;\n}\n\nexport abstract class LinkFactory<T extends LinkModel = LinkModel> extends AbstractFactory<T> {\n\tabstract generateReactWidget(diagramEngine: DiagramEngine, link: T): JSX.Element;\n}\n\nexport abstract class LabelFactory<T extends LabelModel = LabelModel> extends AbstractFactory<T> {\n\tabstract generateReactWidget(diagramEngine: DiagramEngine, label: T): JSX.Element;\n}\n\nexport abstract class PortFactory<T extends PortModel = PortModel> extends AbstractFactory<T> {}\n\nexport class SimplePortFactory extends PortFactory {\n\tcb: (initialConfig?: any) => PortModel;\n\n\tconstructor(type: string, cb: (initialConfig?: any) => PortModel) {\n\t\tsuper(type);\n\t\tthis.cb = cb;\n\t}\n\n\tgetNewInstance(initialConfig?: any): PortModel {\n\t\treturn this.cb(initialConfig);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/AbstractFactory.ts","import { BaseModel, BaseModelListener } from \"./BaseModel\";\nimport { NodeModel } from \"./NodeModel\";\nimport { LinkModel } from \"./LinkModel\";\nimport * as _ from \"lodash\";\nimport { DiagramEngine } from \"../DiagramEngine\";\n\nexport class PortModel extends BaseModel<NodeModel, BaseModelListener> {\n\tname: string;\n\tlinks: { [id: string]: LinkModel };\n\tmaximumLinks: number;\n\n\t// calculated post rendering so routing can be done correctly\n\tx: number;\n\ty: number;\n\twidth: number;\n\theight: number;\n\n\tconstructor(name: string, type?: string, id?: string, maximumLinks?: number) {\n\t\tsuper(type, id);\n\t\tthis.name = name;\n\t\tthis.links = {};\n\t\tthis.maximumLinks = maximumLinks;\n\t}\n\n\tdeSerialize(ob, engine: DiagramEngine) {\n\t\tsuper.deSerialize(ob, engine);\n\t\tthis.name = ob.name;\n\t\tthis.maximumLinks = ob.maximumLinks;\n\t}\n\n\tserialize() {\n\t\treturn _.merge(super.serialize(), {\n\t\t\tname: this.name,\n\t\t\tparentNode: this.parent.id,\n\t\t\tlinks: _.map(this.links, link => {\n\t\t\t\treturn link.id;\n\t\t\t}),\n\t\t\tmaximumLinks: this.maximumLinks\n\t\t});\n\t}\n\n\tdoClone(lookupTable = {}, clone) {\n\t\tclone.links = {};\n\t\tclone.parentNode = this.getParent().clone(lookupTable);\n\t}\n\n\tgetNode(): NodeModel {\n\t\treturn this.getParent();\n\t}\n\n\tgetName(): string {\n\t\treturn this.name;\n\t}\n\n\tgetMaximumLinks(): number {\n\t\treturn this.maximumLinks;\n\t}\n\n\tsetMaximumLinks(maximumLinks: number) {\n\t\tthis.maximumLinks = maximumLinks;\n\t}\n\n\tremoveLink(link: LinkModel) {\n\t\tdelete this.links[link.getID()];\n\t}\n\n\taddLink(link: LinkModel) {\n\t\tthis.links[link.getID()] = link;\n\t}\n\n\tgetLinks(): { [id: string]: LinkModel } {\n\t\treturn this.links;\n\t}\n\n\tpublic createLinkModel(): LinkModel | null {\n\t\tif (_.isFinite(this.maximumLinks)) {\n\t\t\tvar numberOfLinks: number = _.size(this.links);\n\t\t\tif (this.maximumLinks === 1 && numberOfLinks >= 1) {\n\t\t\t\treturn _.values(this.links)[0];\n\t\t\t} else if (numberOfLinks >= this.maximumLinks) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tupdateCoords({ x, y, width, height }: { x: number; y: number; width: number; height: number }) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n\n\tcanLinkToPort(port: PortModel): boolean {\n\t\treturn true;\n\t}\n\n\tisLocked() {\n\t\treturn super.isLocked() || this.getParent().isLocked();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/models/PortModel.ts","import { Toolkit } from \"./Toolkit\";\nimport * as _ from \"lodash\";\nimport { DiagramEngine } from \"./DiagramEngine\";\n\n/**\n * @author Dylan Vorster\n */\nexport interface BaseEvent<T extends BaseEntity = any> {\n\tentity: BaseEntity<BaseListener>;\n\tstopPropagation: () => any;\n\tfiring: boolean;\n\tid: string;\n}\n\nexport interface BaseListener<T extends BaseEntity = any> {\n\tlockChanged?(event: BaseEvent<T> & { locked: boolean }): void;\n}\n\nexport type BaseEntityType = \"node\" | \"link\" | \"port\" | \"point\";\n\nexport class BaseEntity<T extends BaseListener = BaseListener> {\n\tpublic listeners: { [s: string]: T };\n\tpublic id: string;\n\tpublic locked: boolean;\n\n\tconstructor(id?: string) {\n\t\tthis.listeners = {};\n\t\tthis.id = id || Toolkit.UID();\n\t\tthis.locked = false;\n\t}\n\n\tgetID() {\n\t\treturn this.id;\n\t}\n\n\tdoClone(lookupTable = {}, clone) {}\n\n\tclone(lookupTable = {}) {\n\t\t// try and use an existing clone first\n\t\tif (lookupTable[this.id]) {\n\t\t\treturn lookupTable[this.id];\n\t\t}\n\t\tlet clone = _.clone(this);\n\t\tclone.id = Toolkit.UID();\n\t\tclone.clearListeners();\n\t\tlookupTable[this.id] = clone;\n\n\t\tthis.doClone(lookupTable, clone);\n\t\treturn clone;\n\t}\n\n\tclearListeners() {\n\t\tthis.listeners = {};\n\t}\n\n\tpublic deSerialize(data, engine: DiagramEngine) {\n\t\tthis.id = data.id;\n\t}\n\n\tpublic serialize() {\n\t\treturn {\n\t\t\tid: this.id\n\t\t};\n\t}\n\n\tpublic iterateListeners(cb: (t: T, event: BaseEvent) => any) {\n\t\tlet event: BaseEvent = {\n\t\t\tid: Toolkit.UID(),\n\t\t\tfiring: true,\n\t\t\tentity: this,\n\t\t\tstopPropagation: () => {\n\t\t\t\tevent.firing = false;\n\t\t\t}\n\t\t};\n\t\tfor (var i in this.listeners) {\n\t\t\t// propagation stopped\n\t\t\tif (!event.firing) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcb(this.listeners[i], event);\n\t\t}\n\t}\n\n\tpublic removeListener(listener: string) {\n\t\tif (this.listeners[listener]) {\n\t\t\tdelete this.listeners[listener];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic addListener(listener: T): string {\n\t\tvar uid = Toolkit.UID();\n\t\tthis.listeners[uid] = listener;\n\t\treturn uid;\n\t}\n\n\tpublic isLocked(): boolean {\n\t\treturn this.locked;\n\t}\n\n\tpublic setLocked(locked: boolean = true) {\n\t\tthis.locked = locked;\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tif (listener.lockChanged) {\n\t\t\t\tlistener.lockChanged({ ...event, locked: locked });\n\t\t\t}\n\t\t});\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/BaseEntity.ts","module.exports = require('./lib/heap');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/heap/index.js\n// module id = 13\n// module chunks = 0","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/JumpPointFinderBase.js\n// module id = 14\n// module chunks = 0","import * as _ from \"lodash\";\nimport { PortModel } from \"../../models/PortModel\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\nimport { DefaultLinkModel } from \"./DefaultLinkModel\";\nimport { LinkModel } from \"../../models/LinkModel\";\n\nexport class DefaultPortModel extends PortModel {\n\tin: boolean;\n\tlabel: string;\n\tlinks: { [id: string]: DefaultLinkModel };\n\n\tconstructor(isInput: boolean, name: string, label: string = null, id?: string) {\n\t\tsuper(name, \"default\", id);\n\t\tthis.in = isInput;\n\t\tthis.label = label || name;\n\t}\n\n\tdeSerialize(object, engine: DiagramEngine) {\n\t\tsuper.deSerialize(object, engine);\n\t\tthis.in = object.in;\n\t\tthis.label = object.label;\n\t}\n\n\tserialize() {\n\t\treturn _.merge(super.serialize(), {\n\t\t\tin: this.in,\n\t\t\tlabel: this.label\n\t\t});\n\t}\n\n\tlink(port: PortModel): LinkModel {\n\t\tlet link = this.createLinkModel();\n\t\tlink.setSourcePort(this);\n\t\tlink.setTargetPort(port);\n\t\treturn link;\n\t}\n\n\tcanLinkToPort(port: PortModel): boolean {\n\t\tif (port instanceof DefaultPortModel) {\n\t\t\treturn this.in !== port.in;\n\t\t}\n\t\treturn true;\n\t}\n\n\tcreateLinkModel(): LinkModel {\n\t\tlet link = super.createLinkModel();\n\t\treturn link || new DefaultLinkModel();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/models/DefaultPortModel.ts","import * as PF from \"pathfinding\";\nimport { DiagramEngine } from \"../main\";\n\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\nexport const ROUTING_SCALING_FACTOR = 5;\n\nconst pathFinderInstance = new PF.JumpPointFinder({\n\theuristic: PF.Heuristic.manhattan,\n\tdiagonalMovement: PF.DiagonalMovement.Never\n});\n\nexport default class PathFinding {\n\tinstance: any;\n\tdiagramEngine: DiagramEngine;\n\n\tconstructor(diagramEngine: DiagramEngine) {\n\t\tthis.instance = pathFinderInstance;\n\t\tthis.diagramEngine = diagramEngine;\n\t}\n\n\t/**\n\t * Taking as argument a fully unblocked walking matrix, this method\n\t * finds a direct path from point A to B.\n\t */\n\tcalculateDirectPath(\n\t\tfrom: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tto: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t}\n\t): number[][] {\n\t\tconst matrix = this.diagramEngine.getCanvasMatrix();\n\t\tconst grid = new PF.Grid(matrix);\n\n\t\treturn pathFinderInstance.findPath(\n\t\t\tthis.diagramEngine.translateRoutingX(Math.floor(from.x / ROUTING_SCALING_FACTOR)),\n\t\t\tthis.diagramEngine.translateRoutingY(Math.floor(from.y / ROUTING_SCALING_FACTOR)),\n\t\t\tthis.diagramEngine.translateRoutingX(Math.floor(to.x / ROUTING_SCALING_FACTOR)),\n\t\t\tthis.diagramEngine.translateRoutingY(Math.floor(to.y / ROUTING_SCALING_FACTOR)),\n\t\t\tgrid\n\t\t);\n\t}\n\n\t/**\n\t * Using @link{#calculateDirectPath}'s result as input, we here\n\t * determine the first walkable point found in the matrix that includes\n\t * blocked paths.\n\t */\n\tcalculateLinkStartEndCoords(\n\t\tmatrix: number[][],\n\t\tpath: number[][]\n\t): {\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tpathToStart: number[][];\n\t\tpathToEnd: number[][];\n\t} {\n\t\tconst startIndex = path.findIndex(point => matrix[point[1]][point[0]] === 0);\n\t\tconst endIndex =\n\t\t\tpath.length -\n\t\t\t1 -\n\t\t\tpath\n\t\t\t\t.slice()\n\t\t\t\t.reverse()\n\t\t\t\t.findIndex(point => matrix[point[1]][point[0]] === 0);\n\n\t\t// are we trying to create a path exclusively through blocked areas?\n\t\t// if so, let's fallback to the linear routing\n\t\tif (startIndex === -1 || endIndex === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst pathToStart = path.slice(0, startIndex);\n\t\tconst pathToEnd = path.slice(endIndex);\n\n\t\treturn {\n\t\t\tstart: {\n\t\t\t\tx: path[startIndex][0],\n\t\t\t\ty: path[startIndex][1]\n\t\t\t},\n\t\t\tend: {\n\t\t\t\tx: path[endIndex][0],\n\t\t\t\ty: path[endIndex][1]\n\t\t\t},\n\t\t\tpathToStart,\n\t\t\tpathToEnd\n\t\t};\n\t}\n\n\t/**\n\t * Puts everything together: merges the paths from/to the centre of the ports,\n\t * with the path calculated around other elements.\n\t */\n\tcalculateDynamicPath(\n\t\troutingMatrix: number[][],\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tpathToStart: number[][],\n\t\tpathToEnd: number[][]\n\t) {\n\t\t// generate the path based on the matrix with obstacles\n\t\tconst grid = new PF.Grid(routingMatrix);\n\t\tconst dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n\n\t\t// aggregate everything to have the calculated path ready for rendering\n\t\tconst pathCoords = pathToStart\n\t\t\t.concat(dynamicPath, pathToEnd)\n\t\t\t.map(coords => [\n\t\t\t\tthis.diagramEngine.translateRoutingX(coords[0], true),\n\t\t\t\tthis.diagramEngine.translateRoutingY(coords[1], true)\n\t\t\t]);\n\t\treturn PF.Util.compressPath(pathCoords);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/routing/PathFinding.ts","/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\r\nfunction Node(x, y, walkable) {\r\n    /**\r\n     * The x coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.x = x;\r\n    /**\r\n     * The y coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.y = y;\r\n    /**\r\n     * Whether this node can be walked through.\r\n     * @type boolean\r\n     */\r\n    this.walkable = (walkable === undefined ? true : walkable);\r\n}\r\n\r\nmodule.exports = Node;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/core/Node.js\n// module id = 17\n// module chunks = 0","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/AStarFinder.js\n// module id = 18\n// module chunks = 0","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/BiAStarFinder.js\n// module id = 19\n// module chunks = 0","/**\n * @author Dylan Vorster\n */\nimport { LinkModel, LinkModelListener } from \"../../models/LinkModel\";\nimport { BaseEvent } from \"../../BaseEntity\";\nimport * as _ from \"lodash\";\nimport { PointModel } from \"../../models/PointModel\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\nimport { DefaultLabelModel } from \"./DefaultLabelModel\";\nimport { LabelModel } from \"../../models/LabelModel\";\n\nexport interface DefaultLinkModelListener extends LinkModelListener {\n\tcolorChanged?(event: BaseEvent<DefaultLinkModel> & { color: null | string });\n\n\twidthChanged?(event: BaseEvent<DefaultLinkModel> & { width: 0 | number });\n}\n\nexport class DefaultLinkModel extends LinkModel<DefaultLinkModelListener> {\n\twidth: number;\n\tcolor: string;\n\tcurvyness: number;\n\n\tconstructor(type: string = \"default\") {\n\t\tsuper(type);\n\t\tthis.color = \"rgba(255,255,255,0.5)\";\n\t\tthis.width = 3;\n\t\tthis.curvyness = 50;\n\t}\n\n\tserialize() {\n\t\treturn _.merge(super.serialize(), {\n\t\t\twidth: this.width,\n\t\t\tcolor: this.color,\n\t\t\tcurvyness: this.curvyness\n\t\t});\n\t}\n\n\tdeSerialize(ob, engine: DiagramEngine) {\n\t\tsuper.deSerialize(ob, engine);\n\t\tthis.color = ob.color;\n\t\tthis.width = ob.width;\n\t\tthis.curvyness = ob.curvyness;\n\t}\n\n\taddLabel(label: LabelModel | string) {\n\t\tif (label instanceof LabelModel) {\n\t\t\treturn super.addLabel(label);\n\t\t}\n\t\tlet labelOb = new DefaultLabelModel();\n\t\tlabelOb.setLabel(label);\n\t\treturn super.addLabel(labelOb);\n\t}\n\n\tsetWidth(width: number) {\n\t\tthis.width = width;\n\t\tthis.iterateListeners((listener: DefaultLinkModelListener, event: BaseEvent) => {\n\t\t\tlistener.widthChanged && listener.widthChanged({ ...event, width: width });\n\t\t});\n\t}\n\n\tsetColor(color: string) {\n\t\tthis.color = color;\n\t\tthis.iterateListeners((listener: DefaultLinkModelListener, event: BaseEvent) => {\n\t\t\tlistener.colorChanged && listener.colorChanged({ ...event, color: color });\n\t\t});\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/models/DefaultLinkModel.ts","import { BaseModel, BaseModelListener } from \"./BaseModel\";\nimport { PortModel } from \"./PortModel\";\nimport { PointModel } from \"./PointModel\";\nimport * as _ from \"lodash\";\nimport { BaseEvent } from \"../BaseEntity\";\nimport { LabelModel } from \"./LabelModel\";\nimport { DiagramEngine } from \"../DiagramEngine\";\nimport { DiagramModel } from \"./DiagramModel\";\n\nexport interface LinkModelListener extends BaseModelListener {\n\tsourcePortChanged?(event: BaseEvent<LinkModel> & { port: null | PortModel }): void;\n\n\ttargetPortChanged?(event: BaseEvent<LinkModel> & { port: null | PortModel }): void;\n}\n\nexport class LinkModel<T extends LinkModelListener = LinkModelListener> extends BaseModel<DiagramModel, T> {\n\tsourcePort: PortModel | null;\n\ttargetPort: PortModel | null;\n\tlabels: LabelModel[];\n\tpoints: PointModel[];\n\textras: {};\n\n\tconstructor(linkType: string = \"default\", id?: string) {\n\t\tsuper(linkType, id);\n\t\tthis.points = [new PointModel(this, { x: 0, y: 0 }), new PointModel(this, { x: 0, y: 0 })];\n\t\tthis.extras = {};\n\t\tthis.sourcePort = null;\n\t\tthis.targetPort = null;\n\t\tthis.labels = [];\n\t}\n\n\tdeSerialize(ob, engine: DiagramEngine) {\n\t\tsuper.deSerialize(ob, engine);\n\t\tthis.extras = ob.extras;\n\t\tthis.points = _.map(ob.points || [], (point: { x; y }) => {\n\t\t\tvar p = new PointModel(this, { x: point.x, y: point.y });\n\t\t\tp.deSerialize(point, engine);\n\t\t\treturn p;\n\t\t});\n\n\t\t//deserialize labels\n\t\t_.forEach(ob.labels || [], (label: any) => {\n\t\t\tlet labelOb = engine.getLabelFactory(label.type).getNewInstance();\n\t\t\tlabelOb.deSerialize(label, engine);\n\t\t\tthis.addLabel(labelOb);\n\t\t});\n\n\t\tif (ob.target) {\n\t\t\tthis.setTargetPort(\n\t\t\t\tthis.getParent()\n\t\t\t\t\t.getNode(ob.target)\n\t\t\t\t\t.getPortFromID(ob.targetPort)\n\t\t\t);\n\t\t}\n\n\t\tif (ob.source) {\n\t\t\tthis.setSourcePort(\n\t\t\t\tthis.getParent()\n\t\t\t\t\t.getNode(ob.source)\n\t\t\t\t\t.getPortFromID(ob.sourcePort)\n\t\t\t);\n\t\t}\n\t}\n\n\tserialize() {\n\t\treturn _.merge(super.serialize(), {\n\t\t\tsource: this.sourcePort ? this.sourcePort.getParent().id : null,\n\t\t\tsourcePort: this.sourcePort ? this.sourcePort.id : null,\n\t\t\ttarget: this.targetPort ? this.targetPort.getParent().id : null,\n\t\t\ttargetPort: this.targetPort ? this.targetPort.id : null,\n\t\t\tpoints: _.map(this.points, point => {\n\t\t\t\treturn point.serialize();\n\t\t\t}),\n\t\t\textras: this.extras,\n\t\t\tlabels: _.map(this.labels, label => {\n\t\t\t\treturn label.serialize();\n\t\t\t})\n\t\t});\n\t}\n\n\tdoClone(lookupTable = {}, clone) {\n\t\tclone.setPoints(\n\t\t\t_.map(this.getPoints(), (point: PointModel) => {\n\t\t\t\treturn point.clone(lookupTable);\n\t\t\t})\n\t\t);\n\t\tif (this.sourcePort) {\n\t\t\tclone.setSourcePort(this.sourcePort.clone(lookupTable));\n\t\t}\n\t\tif (this.targetPort) {\n\t\t\tclone.setTargetPort(this.targetPort.clone(lookupTable));\n\t\t}\n\t}\n\n\tremove() {\n\t\tif (this.sourcePort) {\n\t\t\tthis.sourcePort.removeLink(this);\n\t\t}\n\t\tif (this.targetPort) {\n\t\t\tthis.targetPort.removeLink(this);\n\t\t}\n\t\tsuper.remove();\n\t}\n\n\tisLastPoint(point: PointModel) {\n\t\tvar index = this.getPointIndex(point);\n\t\treturn index === this.points.length - 1;\n\t}\n\n\tgetPointIndex(point: PointModel) {\n\t\treturn this.points.indexOf(point);\n\t}\n\n\tgetPointModel(id: string): PointModel | null {\n\t\tfor (var i = 0; i < this.points.length; i++) {\n\t\t\tif (this.points[i].id === id) {\n\t\t\t\treturn this.points[i];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetPortForPoint(point: PointModel): PortModel {\n\t\tif (this.sourcePort !== null && this.getFirstPoint().getID() === point.getID()) {\n\t\t\treturn this.sourcePort;\n\t\t}\n\t\tif (this.targetPort !== null && this.getLastPoint().getID() === point.getID()) {\n\t\t\treturn this.targetPort;\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetPointForPort(port: PortModel): PointModel {\n\t\tif (this.sourcePort !== null && this.sourcePort.getID() === port.getID()) {\n\t\t\treturn this.getFirstPoint();\n\t\t}\n\t\tif (this.targetPort !== null && this.targetPort.getID() === port.getID()) {\n\t\t\treturn this.getLastPoint();\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetFirstPoint(): PointModel {\n\t\treturn this.points[0];\n\t}\n\n\tgetLastPoint(): PointModel {\n\t\treturn this.points[this.points.length - 1];\n\t}\n\n\tsetSourcePort(port: PortModel) {\n\t\tif (port !== null) {\n\t\t\tport.addLink(this);\n\t\t} else if (this.sourcePort !== null) {\n\t\t\tthis.sourcePort.removeLink(this);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tthis.sourcePort = port;\n\t\tthis.iterateListeners((listener: LinkModelListener, event) => {\n\t\t\tlistener.sourcePortChanged && listener.sourcePortChanged({ ...event, port: port });\n\t\t});\n\t}\n\n\tgetSourcePort(): PortModel {\n\t\treturn this.sourcePort;\n\t}\n\n\tgetTargetPort(): PortModel {\n\t\treturn this.targetPort;\n\t}\n\n\tsetTargetPort(port: PortModel) {\n\t\tif (port !== null) {\n\t\t\tport.addLink(this);\n\t\t} else if (this.targetPort !== null) {\n\t\t\tthis.targetPort.removeLink(this);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tthis.targetPort = port;\n\t\tthis.iterateListeners((listener: LinkModelListener, event) => {\n\t\t\tlistener.targetPortChanged && listener.targetPortChanged({ ...event, port: port });\n\t\t});\n\t}\n\n\tpoint(x: number, y: number): PointModel {\n\t\treturn this.addPoint(this.generatePoint(x, y));\n\t}\n\n\taddLabel(label: LabelModel) {\n\t\tlabel.setParent(this);\n\t\tthis.labels.push(label);\n\t}\n\n\tgetPoints(): PointModel[] {\n\t\treturn this.points;\n\t}\n\n\tsetPoints(points: PointModel[]) {\n\t\t_.forEach(points, point => {\n\t\t\tpoint.setParent(this);\n\t\t});\n\t\tthis.points = points;\n\t}\n\n\tremovePoint(pointModel: PointModel) {\n\t\tthis.points.splice(this.getPointIndex(pointModel), 1);\n\t}\n\n\tremovePointsBefore(pointModel: PointModel) {\n\t\tthis.points.splice(0, this.getPointIndex(pointModel));\n\t}\n\n\tremovePointsAfter(pointModel: PointModel) {\n\t\tthis.points.splice(this.getPointIndex(pointModel) + 1);\n\t}\n\n\tremoveMiddlePoints() {\n\t\tif (this.points.length > 2) {\n\t\t\tthis.points.splice(0, this.points.length - 2);\n\t\t}\n\t}\n\n\taddPoint<T extends PointModel>(pointModel: T, index = 1): T {\n\t\tpointModel.setParent(this);\n\t\tthis.points.splice(index, 0, pointModel);\n\t\treturn pointModel;\n\t}\n\n\tgeneratePoint(x: number = 0, y: number = 0): PointModel {\n\t\treturn new PointModel(this, { x: x, y: y });\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/models/LinkModel.ts","import { BaseListener, BaseEntity, BaseEvent, BaseEntityType } from \"../BaseEntity\";\nimport * as _ from \"lodash\";\nimport { DiagramEngine } from \"../DiagramEngine\";\nimport { LinkModel } from \"./LinkModel\";\nimport { NodeModel } from \"./NodeModel\";\nimport { PortModel } from \"./PortModel\";\nimport { BaseModel, BaseModelListener } from \"./BaseModel\";\nimport { PointModel } from \"./PointModel\";\n/**\n * @author Dylan Vorster\n *\n */\nexport interface DiagramListener extends BaseListener {\n\tnodesUpdated?(event: BaseEvent & { node: NodeModel; isCreated: boolean }): void;\n\n\tlinksUpdated?(event: BaseEvent & { link: LinkModel; isCreated: boolean }): void;\n\n\toffsetUpdated?(event: BaseEvent<DiagramModel> & { offsetX: number; offsetY: number }): void;\n\n\tzoomUpdated?(event: BaseEvent<DiagramModel> & { zoom: number }): void;\n\n\tgridUpdated?(event: BaseEvent<DiagramModel> & { size: number }): void;\n}\n\n/**\n *\n */\nexport class DiagramModel extends BaseEntity<DiagramListener> {\n\t//models\n\tlinks: { [s: string]: LinkModel };\n\tnodes: { [s: string]: NodeModel };\n\n\t//control variables\n\toffsetX: number;\n\toffsetY: number;\n\tzoom: number;\n\trendered: boolean;\n\tgridSize: number;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.links = {};\n\t\tthis.nodes = {};\n\n\t\tthis.offsetX = 0;\n\t\tthis.offsetY = 0;\n\t\tthis.zoom = 100;\n\t\tthis.rendered = false;\n\t\tthis.gridSize = 0;\n\t}\n\n\tsetGridSize(size: number = 0) {\n\t\tthis.gridSize = size;\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tlistener.gridUpdated && listener.gridUpdated({ ...event, size: size });\n\t\t});\n\t}\n\n\tgetGridPosition(pos) {\n\t\tif (this.gridSize === 0) {\n\t\t\treturn pos;\n\t\t}\n\t\treturn this.gridSize * Math.floor((pos + this.gridSize / 2) / this.gridSize);\n\t}\n\n\tdeSerializeDiagram(object: any, diagramEngine: DiagramEngine) {\n\t\tthis.deSerialize(object, diagramEngine);\n\n\t\tthis.offsetX = object.offsetX;\n\t\tthis.offsetY = object.offsetY;\n\t\tthis.zoom = object.zoom;\n\t\tthis.gridSize = object.gridSize;\n\n\t\t// deserialize nodes\n\t\t_.forEach(object.nodes, (node: any) => {\n\t\t\tlet nodeOb = diagramEngine.getNodeFactory(node.type).getNewInstance(node);\n\t\t\tnodeOb.setParent(this);\n\t\t\tnodeOb.deSerialize(node, diagramEngine);\n\t\t\tthis.addNode(nodeOb);\n\t\t});\n\n\t\t// deserialze links\n\t\t_.forEach(object.links, (link: any) => {\n\t\t\tlet linkOb = diagramEngine.getLinkFactory(link.type).getNewInstance();\n\t\t\tlinkOb.setParent(this);\n\t\t\tlinkOb.deSerialize(link, diagramEngine);\n\t\t\tthis.addLink(linkOb);\n\t\t});\n\t}\n\n\tserializeDiagram() {\n\t\treturn _.merge(this.serialize(), {\n\t\t\toffsetX: this.offsetX,\n\t\t\toffsetY: this.offsetY,\n\t\t\tzoom: this.zoom,\n\t\t\tgridSize: this.gridSize,\n\t\t\tlinks: _.map(this.links, link => {\n\t\t\t\treturn link.serialize();\n\t\t\t}),\n\t\t\tnodes: _.map(this.nodes, node => {\n\t\t\t\treturn node.serialize();\n\t\t\t})\n\t\t});\n\t}\n\n\tclearSelection(ignore: BaseModel<BaseEntity, BaseModelListener> | null = null) {\n\t\t_.forEach(this.getSelectedItems(), element => {\n\t\t\tif (ignore && ignore.getID() === element.getID()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telement.setSelected(false); //TODO dont fire the listener\n\t\t});\n\t}\n\n\tgetSelectedItems(...filters: BaseEntityType[]): BaseModel<BaseEntity, BaseModelListener>[] {\n\t\tif (!Array.isArray(filters)) {\n\t\t\tfilters = [filters];\n\t\t}\n\t\tvar items = [];\n\n\t\t// run through nodes\n\t\titems = items.concat(\n\t\t\t_.flatMap(this.nodes, node => {\n\t\t\t\treturn node.getSelectedEntities();\n\t\t\t})\n\t\t);\n\n\t\t// find all the links\n\t\titems = items.concat(\n\t\t\t_.flatMap(this.links, link => {\n\t\t\t\treturn link.getSelectedEntities();\n\t\t\t})\n\t\t);\n\n\t\t//find all points\n\t\titems = items.concat(\n\t\t\t_.flatMap(this.links, link => {\n\t\t\t\treturn _.flatMap(link.points, point => {\n\t\t\t\t\treturn point.getSelectedEntities();\n\t\t\t\t});\n\t\t\t})\n\t\t);\n\n\t\titems = _.uniq(items);\n\n\t\tif (filters.length > 0) {\n\t\t\titems = _.filter(_.uniq(items), (item: BaseModel<any>) => {\n\t\t\t\tif (_.includes(filters, \"node\") && item instanceof NodeModel) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (_.includes(filters, \"link\") && item instanceof LinkModel) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (_.includes(filters, \"port\") && item instanceof PortModel) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (_.includes(filters, \"point\") && item instanceof PointModel) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\n\t\treturn items;\n\t}\n\n\tsetZoomLevel(zoom: number) {\n\t\tthis.zoom = zoom;\n\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tlistener.zoomUpdated && listener.zoomUpdated({ ...event, zoom: zoom });\n\t\t});\n\t}\n\n\tsetOffset(offsetX: number, offsetY: number) {\n\t\tthis.offsetX = offsetX;\n\t\tthis.offsetY = offsetY;\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tlistener.offsetUpdated && listener.offsetUpdated({ ...event, offsetX: offsetX, offsetY: offsetY });\n\t\t});\n\t}\n\n\tsetOffsetX(offsetX: number) {\n\t\tthis.offsetX = offsetX;\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tlistener.offsetUpdated && listener.offsetUpdated({ ...event, offsetX: offsetX, offsetY: this.offsetY });\n\t\t});\n\t}\n\tsetOffsetY(offsetY: number) {\n\t\tthis.offsetY = offsetY;\n\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tlistener.offsetUpdated &&\n\t\t\t\tlistener.offsetUpdated({ ...event, offsetX: this.offsetX, offsetY: this.offsetY });\n\t\t});\n\t}\n\n\tgetOffsetY() {\n\t\treturn this.offsetY;\n\t}\n\n\tgetOffsetX() {\n\t\treturn this.offsetX;\n\t}\n\n\tgetZoomLevel() {\n\t\treturn this.zoom;\n\t}\n\n\tgetNode(node: string | NodeModel): NodeModel | null {\n\t\tif (node instanceof NodeModel) {\n\t\t\treturn node;\n\t\t}\n\t\tif (!this.nodes[node]) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.nodes[node];\n\t}\n\n\tgetLink(link: string | LinkModel): LinkModel | null {\n\t\tif (link instanceof LinkModel) {\n\t\t\treturn link;\n\t\t}\n\t\tif (!this.links[link]) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.links[link];\n\t}\n\n\taddAll(...models: BaseModel[]): BaseModel[] {\n\t\t_.forEach(models, model => {\n\t\t\tif (model instanceof LinkModel) {\n\t\t\t\tthis.addLink(model);\n\t\t\t} else if (model instanceof NodeModel) {\n\t\t\t\tthis.addNode(model);\n\t\t\t}\n\t\t});\n\t\treturn models;\n\t}\n\n\taddLink(link: LinkModel): LinkModel {\n\t\tlink.addListener({\n\t\t\tentityRemoved: () => {\n\t\t\t\tthis.removeLink(link);\n\t\t\t}\n\t\t});\n\t\tthis.links[link.getID()] = link;\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tlistener.linksUpdated && listener.linksUpdated({ ...event, link: link, isCreated: true });\n\t\t});\n\t\treturn link;\n\t}\n\n\taddNode(node: NodeModel): NodeModel {\n\t\tnode.addListener({\n\t\t\tentityRemoved: () => {\n\t\t\t\tthis.removeNode(node);\n\t\t\t}\n\t\t});\n\t\tthis.nodes[node.getID()] = node;\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tlistener.nodesUpdated && listener.nodesUpdated({ ...event, node: node, isCreated: true });\n\t\t});\n\t\treturn node;\n\t}\n\n\tremoveLink(link: LinkModel | string) {\n\t\tlink = this.getLink(link);\n\t\tdelete this.links[link.getID()];\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tlistener.linksUpdated && listener.linksUpdated({ ...event, link: link as LinkModel, isCreated: false });\n\t\t});\n\t}\n\n\tremoveNode(node: NodeModel | string) {\n\t\tnode = this.getNode(node);\n\t\tdelete this.nodes[node.getID()];\n\t\tthis.iterateListeners((listener, event) => {\n\t\t\tlistener.nodesUpdated && listener.nodesUpdated({ ...event, node: node as NodeModel, isCreated: false });\n\t\t});\n\t}\n\n\tgetLinks(): { [s: string]: LinkModel } {\n\t\treturn this.links;\n\t}\n\n\tgetNodes(): { [s: string]: NodeModel } {\n\t\treturn this.nodes;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/models/DiagramModel.ts","/**\n * @author Dylan Vorster\n */\n\n//export defaults\nexport * from \"./defaults/models/DefaultNodeModel\";\nexport * from \"./defaults/models/DefaultPortModel\";\nexport * from \"./defaults/models/DefaultLinkModel\";\n\nexport * from \"./defaults/factories/DefaultLinkFactory\";\nexport * from \"./defaults/factories/DefaultNodeFactory\";\nexport * from \"./defaults/factories/DefaultPortFactory\";\n\nexport * from \"./defaults/widgets/DefaultLinkWidget\";\nexport * from \"./defaults/widgets/DefaultNodeWidget\";\nexport * from \"./defaults/widgets/DefaultPortLabelWidget\";\n\nexport * from \"./AbstractFactory\";\nexport * from \"./Toolkit\";\n\nexport * from \"./DiagramEngine\";\nexport * from \"./models/DiagramModel\";\nexport * from \"./BaseEntity\";\nexport * from \"./CanvasActions\";\n\nexport * from \"./models/BaseModel\";\nexport * from \"./models/DiagramModel\";\nexport * from \"./models/LinkModel\";\nexport * from \"./models/NodeModel\";\nexport * from \"./models/PointModel\";\nexport * from \"./models/PortModel\";\n\nexport * from \"./widgets/DiagramWidget\";\nexport * from \"./widgets/layers/LinkLayerWidget\";\nexport * from \"./widgets/LinkWidget\";\nexport * from \"./widgets/layers/NodeLayerWidget\";\nexport * from \"./widgets/NodeWidget\";\nexport * from \"./widgets/PortWidget\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","import { DefaultPortModel } from \"./DefaultPortModel\";\nimport * as _ from \"lodash\";\n\nimport { NodeModel } from \"../../models/NodeModel\";\nimport { Toolkit } from \"../../Toolkit\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\n\n/**\n * @author Dylan Vorster\n */\nexport class DefaultNodeModel extends NodeModel {\n\tname: string;\n\tcolor: string;\n\tports: { [s: string]: DefaultPortModel };\n\n\tconstructor(name: string = \"Untitled\", color: string = \"rgb(0,192,255)\") {\n\t\tsuper(\"default\");\n\t\tthis.name = name;\n\t\tthis.color = color;\n\t}\n\n\taddInPort(label: string): DefaultPortModel {\n\t\treturn this.addPort(new DefaultPortModel(true, Toolkit.UID(), label));\n\t}\n\n\taddOutPort(label: string): DefaultPortModel {\n\t\treturn this.addPort(new DefaultPortModel(false, Toolkit.UID(), label));\n\t}\n\n\tdeSerialize(object, engine: DiagramEngine) {\n\t\tsuper.deSerialize(object, engine);\n\t\tthis.name = object.name;\n\t\tthis.color = object.color;\n\t}\n\n\tserialize() {\n\t\treturn _.merge(super.serialize(), {\n\t\t\tname: this.name,\n\t\t\tcolor: this.color\n\t\t});\n\t}\n\n\tgetInPorts(): DefaultPortModel[] {\n\t\treturn _.filter(this.ports, portModel => {\n\t\t\treturn portModel.in;\n\t\t});\n\t}\n\n\tgetOutPorts(): DefaultPortModel[] {\n\t\treturn _.filter(this.ports, portModel => {\n\t\t\treturn !portModel.in;\n\t\t});\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/models/DefaultNodeModel.ts","import { LabelModel } from \"../../models/LabelModel\";\n\nexport class DefaultLabelModel extends LabelModel {\n\tlabel: string;\n\n\tconstructor() {\n\t\tsuper(\"default\");\n\t\tthis.offsetY = -23;\n\t}\n\n\tsetLabel(label: string) {\n\t\tthis.label = label;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/models/DefaultLabelModel.tsx","import { BaseModel } from \"./BaseModel\";\nimport { LinkModel } from \"./LinkModel\";\n\nexport class LabelModel extends BaseModel<LinkModel> {\n\toffsetX: number;\n\toffsetY: number;\n\n\tconstructor(type?: string, id?: string) {\n\t\tsuper(type, id);\n\t\tthis.offsetX = 0;\n\t\tthis.offsetY = 0;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/models/LabelModel.ts","import * as React from \"react\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\nimport { PointModel } from \"../../models/PointModel\";\nimport { Toolkit } from \"../../Toolkit\";\nimport { DefaultLinkFactory } from \"../factories/DefaultLinkFactory\";\nimport { DefaultLinkModel } from \"../models/DefaultLinkModel\";\nimport PathFinding from \"../../routing/PathFinding\";\nimport * as _ from \"lodash\";\nimport { LabelModel } from \"../../models/LabelModel\";\nimport { BaseWidget, BaseWidgetProps } from \"../../widgets/BaseWidget\";\n\nexport interface DefaultLinkProps extends BaseWidgetProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: DefaultLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tpointAdded?: (point: PointModel, event: MouseEvent) => any;\n}\n\nexport interface DefaultLinkState {\n\tselected: boolean;\n}\n\nexport class DefaultLinkWidget extends BaseWidget<DefaultLinkProps, DefaultLinkState> {\n\tpublic static defaultProps: DefaultLinkProps = {\n\t\tcolor: \"black\",\n\t\twidth: 3,\n\t\tlink: null,\n\t\tengine: null,\n\t\tsmooth: false,\n\t\tdiagramEngine: null\n\t};\n\n\t// DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n\trefLabels: { [id: string]: HTMLElement };\n\trefPaths: SVGPathElement[];\n\n\tpathFinding: PathFinding; // only set when smart routing is active\n\n\tconstructor(props: DefaultLinkProps) {\n\t\tsuper(\"srd-default-link\", props);\n\n\t\tthis.refLabels = {};\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\n\t\tif (props.diagramEngine.isSmartRoutingEnabled()) {\n\t\t\tthis.pathFinding = new PathFinding(this.props.diagramEngine);\n\t\t}\n\t}\n\n\tcalculateAllLabelPosition() {\n\t\t_.forEach(this.props.link.labels, (label, index) => {\n\t\t\tthis.calculateLabelPosition(label, index + 1);\n\t\t});\n\t}\n\n\tcomponentDidUpdate() {\n\t\tif (this.props.link.labels.length > 0) {\n\t\t\twindow.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n\t\t}\n\t}\n\n\tcomponentDidMount() {\n\t\tif (this.props.link.labels.length > 0) {\n\t\t\twindow.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n\t\t}\n\t}\n\n\taddPointToLink = (event: MouseEvent, index: number): void => {\n\t\tif (\n\t\t\t!event.shiftKey &&\n\t\t\t!this.props.diagramEngine.isModelLocked(this.props.link) &&\n\t\t\tthis.props.link.points.length - 1 <= this.props.diagramEngine.getMaxNumberPointsPerLink()\n\t\t) {\n\t\t\tconst point = new PointModel(this.props.link, this.props.diagramEngine.getRelativeMousePoint(event));\n\t\t\tpoint.setSelected(true);\n\t\t\tthis.forceUpdate();\n\t\t\tthis.props.link.addPoint(point, index);\n\t\t\tthis.props.pointAdded(point, event);\n\t\t}\n\t};\n\n\tgeneratePoint(pointIndex: number): JSX.Element {\n\t\tlet x = this.props.link.points[pointIndex].x;\n\t\tlet y = this.props.link.points[pointIndex].y;\n\n\t\treturn (\n\t\t\t<g key={\"point-\" + this.props.link.points[pointIndex].id}>\n\t\t\t\t<circle\n\t\t\t\t\tcx={x}\n\t\t\t\t\tcy={y}\n\t\t\t\t\tr={5}\n\t\t\t\t\tclassName={\n\t\t\t\t\t\t\"point \" +\n\t\t\t\t\t\tthis.bem(\"__point\") +\n\t\t\t\t\t\t(this.props.link.points[pointIndex].isSelected() ? this.bem(\"--point-selected\") : \"\")\n\t\t\t\t\t}\n\t\t\t\t/>\n\t\t\t\t<circle\n\t\t\t\t\tonMouseLeave={() => {\n\t\t\t\t\t\tthis.setState({ selected: false });\n\t\t\t\t\t}}\n\t\t\t\t\tonMouseEnter={() => {\n\t\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t\t}}\n\t\t\t\t\tdata-id={this.props.link.points[pointIndex].id}\n\t\t\t\t\tdata-linkid={this.props.link.id}\n\t\t\t\t\tcx={x}\n\t\t\t\t\tcy={y}\n\t\t\t\t\tr={15}\n\t\t\t\t\topacity={0}\n\t\t\t\t\tclassName={\"point \" + this.bem(\"__point\")}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t);\n\t}\n\n\tgenerateLabel(label: LabelModel) {\n\t\tconst canvas = this.props.diagramEngine.canvas as HTMLElement;\n\t\treturn (\n\t\t\t<foreignObject\n\t\t\t\tkey={label.id}\n\t\t\t\tclassName={this.bem(\"__label\")}\n\t\t\t\twidth={canvas.offsetWidth}\n\t\t\t\theight={canvas.offsetHeight}\n\t\t\t>\n\t\t\t\t<div ref={ref => (this.refLabels[label.id] = ref)}>\n\t\t\t\t\t{this.props.diagramEngine\n\t\t\t\t\t\t.getFactoryForLabel(label)\n\t\t\t\t\t\t.generateReactWidget(this.props.diagramEngine, label)}\n\t\t\t\t</div>\n\t\t\t</foreignObject>\n\t\t);\n\t}\n\n\tgenerateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n\t\tvar props = this.props;\n\n\t\tvar Bottom = React.cloneElement(\n\t\t\t(props.diagramEngine.getFactoryForLink(this.props.link) as DefaultLinkFactory).generateLinkSegment(\n\t\t\t\tthis.props.link,\n\t\t\t\tthis,\n\t\t\t\tthis.state.selected || this.props.link.isSelected(),\n\t\t\t\tpath\n\t\t\t),\n\t\t\t{\n\t\t\t\tref: ref => ref && this.refPaths.push(ref)\n\t\t\t}\n\t\t);\n\n\t\tvar Top = React.cloneElement(Bottom, {\n\t\t\t...extraProps,\n\t\t\tstrokeLinecap: \"round\",\n\t\t\tonMouseLeave: () => {\n\t\t\t\tthis.setState({ selected: false });\n\t\t\t},\n\t\t\tonMouseEnter: () => {\n\t\t\t\tthis.setState({ selected: true });\n\t\t\t},\n\t\t\tref: null,\n\t\t\t\"data-linkid\": this.props.link.getID(),\n\t\t\tstrokeOpacity: this.state.selected ? 0.1 : 0,\n\t\t\tstrokeWidth: 20,\n\t\t\tonContextMenu: () => {\n\t\t\t\tif (!this.props.diagramEngine.isModelLocked(this.props.link)) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tthis.props.link.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn (\n\t\t\t<g key={\"link-\" + id}>\n\t\t\t\t{Bottom}\n\t\t\t\t{Top}\n\t\t\t</g>\n\t\t);\n\t}\n\n\tfindPathAndRelativePositionToRenderLabel = (index: number): { path: any; position: number } => {\n\t\t// an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\n\t\tconst lengths = this.refPaths.map(path => path.getTotalLength());\n\n\t\t// calculate the point where we want to display the label\n\t\tlet labelPosition =\n\t\t\tlengths.reduce((previousValue, currentValue) => previousValue + currentValue, 0) *\n\t\t\t(index / (this.props.link.labels.length + 1));\n\n\t\t// find the path where the label will be rendered and calculate the relative position\n\t\tlet pathIndex = 0;\n\t\twhile (pathIndex < this.refPaths.length) {\n\t\t\tif (labelPosition - lengths[pathIndex] < 0) {\n\t\t\t\treturn {\n\t\t\t\t\tpath: this.refPaths[pathIndex],\n\t\t\t\t\tposition: labelPosition\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// keep searching\n\t\t\tlabelPosition -= lengths[pathIndex];\n\t\t\tpathIndex++;\n\t\t}\n\t};\n\n\tcalculateLabelPosition = (label, index: number) => {\n\t\tif (!this.refLabels[label.id]) {\n\t\t\t// no label? nothing to do here\n\t\t\treturn;\n\t\t}\n\n\t\tconst { path, position } = this.findPathAndRelativePositionToRenderLabel(index);\n\n\t\tconst labelDimensions = {\n\t\t\twidth: this.refLabels[label.id].offsetWidth,\n\t\t\theight: this.refLabels[label.id].offsetHeight\n\t\t};\n\n\t\tconst pathCentre = path.getPointAtLength(position);\n\n\t\tconst labelCoordinates = {\n\t\t\tx: pathCentre.x - labelDimensions.width / 2 + label.offsetX,\n\t\t\ty: pathCentre.y - labelDimensions.height / 2 + label.offsetY\n\t\t};\n\t\tthis.refLabels[label.id].setAttribute(\n\t\t\t\"style\",\n\t\t\t`transform: translate(${labelCoordinates.x}px, ${labelCoordinates.y}px);`\n\t\t);\n\t};\n\n\t/**\n\t * Smart routing is only applicable when all conditions below are true:\n\t * - smart routing is set to true on the engine\n\t * - current link is between two nodes (not between a node and an empty point)\n\t * - no custom points exist along the line\n\t */\n\tisSmartRoutingApplicable(): boolean {\n\t\tconst { diagramEngine, link } = this.props;\n\n\t\tif (!diagramEngine.isSmartRoutingEnabled()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (link.points.length !== 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (link.sourcePort === null || link.targetPort === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\trender() {\n\t\tconst { diagramEngine } = this.props;\n\t\tif (!diagramEngine.nodesRendered) {\n\t\t\treturn null;\n\t\t}\n\n\t\t//ensure id is present for all points on the path\n\t\tvar points = this.props.link.points;\n\t\tvar paths = [];\n\n\t\tif (this.isSmartRoutingApplicable()) {\n\t\t\t// first step: calculate a direct path between the points being linked\n\t\t\tconst directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n\n\t\t\tconst routingMatrix = diagramEngine.getRoutingMatrix();\n\t\t\t// now we need to extract, from the routing matrix, the very first walkable points\n\t\t\t// so they can be used as origin and destination of the link to be created\n\t\t\tconst smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\n\t\t\tif (smartLink) {\n\t\t\t\tconst { start, end, pathToStart, pathToEnd } = smartLink;\n\n\t\t\t\t// second step: calculate a path avoiding hitting other elements\n\t\t\t\tconst simplifiedPath = this.pathFinding.calculateDynamicPath(\n\t\t\t\t\troutingMatrix,\n\t\t\t\t\tstart,\n\t\t\t\t\tend,\n\t\t\t\t\tpathToStart,\n\t\t\t\t\tpathToEnd\n\t\t\t\t);\n\n\t\t\t\tpaths.push(\n\t\t\t\t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n\t\t\t\t\tthis.generateLink(\n\t\t\t\t\t\tToolkit.generateDynamicPath(simplifiedPath),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tonMouseDown: event => {\n\t\t\t\t\t\t\t\tthis.addPointToLink(event, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"0\"\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// true when smart routing was skipped or not enabled.\n\t\t// See @link{#isSmartRoutingApplicable()}.\n\t\tif (paths.length === 0) {\n\t\t\tif (points.length === 2) {\n\t\t\t\t//draw the smoothing\n\t\t\t\t//if the points are too close, just draw a straight line\n\t\t\t\tvar margin = 50;\n\t\t\t\tif (Math.abs(points[0].x - points[1].x) < 50) {\n\t\t\t\t\tmargin = 5;\n\t\t\t\t}\n\n\t\t\t\tvar pointLeft = points[0];\n\t\t\t\tvar pointRight = points[1];\n\n\t\t\t\t//some defensive programming to make sure the smoothing is\n\t\t\t\t//always in the right direction\n\t\t\t\tif (pointLeft.x > pointRight.x) {\n\t\t\t\t\tpointLeft = points[1];\n\t\t\t\t\tpointRight = points[0];\n\t\t\t\t}\n\n\t\t\t\tpaths.push(\n\t\t\t\t\tthis.generateLink(\n\t\t\t\t\t\tToolkit.generateCurvePath(pointLeft, pointRight, this.props.link.curvyness),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tonMouseDown: event => {\n\t\t\t\t\t\t\t\tthis.addPointToLink(event, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"0\"\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t// draw the link as dangeling\n\t\t\t\tif (this.props.link.targetPort === null) {\n\t\t\t\t\tpaths.push(this.generatePoint(1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//draw the multiple anchors and complex line instead\n\t\t\t\tfor (let i = 0; i < points.length - 1; i++) {\n\t\t\t\t\tpaths.push(\n\t\t\t\t\t\tthis.generateLink(\n\t\t\t\t\t\t\tToolkit.generateLinePath(points[i], points[i + 1]),\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"data-linkid\": this.props.link.id,\n\t\t\t\t\t\t\t\t\"data-point\": i,\n\t\t\t\t\t\t\t\tonMouseDown: (event: MouseEvent) => {\n\t\t\t\t\t\t\t\t\tthis.addPointToLink(event, i + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t//render the circles\n\t\t\t\tfor (var i = 1; i < points.length - 1; i++) {\n\t\t\t\t\tpaths.push(this.generatePoint(i));\n\t\t\t\t}\n\n\t\t\t\tif (this.props.link.targetPort === null) {\n\t\t\t\t\tpaths.push(this.generatePoint(points.length - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.refPaths = [];\n\t\treturn (\n\t\t\t<g {...this.getProps()}>\n\t\t\t\t{paths}\n\t\t\t\t{_.map(this.props.link.labels, labelModel => {\n\t\t\t\t\treturn this.generateLabel(labelModel);\n\t\t\t\t})}\n\t\t\t</g>\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/widgets/DefaultLinkWidget.tsx","import * as React from \"react\";\nimport * as _ from \"lodash\";\nimport { DefaultNodeModel } from \"../models/DefaultNodeModel\";\nimport { DefaultPortLabel } from \"./DefaultPortLabelWidget\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\nimport { BaseWidget, BaseWidgetProps } from \"../../widgets/BaseWidget\";\n\nexport interface DefaultNodeProps extends BaseWidgetProps {\n\tnode: DefaultNodeModel;\n\tdiagramEngine: DiagramEngine;\n}\n\nexport interface DefaultNodeState {}\n\n/**\n * @author Dylan Vorster\n */\nexport class DefaultNodeWidget extends BaseWidget<DefaultNodeProps, DefaultNodeState> {\n\tconstructor(props: DefaultNodeProps) {\n\t\tsuper(\"srd-default-node\", props);\n\t\tthis.state = {};\n\t}\n\n\tgeneratePort(port) {\n\t\treturn <DefaultPortLabel model={port} key={port.id} />;\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div {...this.getProps()} style={{ background: this.props.node.color }}>\n\t\t\t\t<div className={this.bem(\"__title\")}>\n\t\t\t\t\t<div className={this.bem(\"__name\")}>{this.props.node.name}</div>\n\t\t\t\t</div>\n\t\t\t\t<div className={this.bem(\"__ports\")}>\n\t\t\t\t\t<div className={this.bem(\"__in\")}>\n\t\t\t\t\t\t{_.map(this.props.node.getInPorts(), this.generatePort.bind(this))}\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className={this.bem(\"__out\")}>\n\t\t\t\t\t\t{_.map(this.props.node.getOutPorts(), this.generatePort.bind(this))}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/widgets/DefaultNodeWidget.tsx","import * as React from \"react\";\nimport { DefaultPortModel } from \"../models/DefaultPortModel\";\nimport { PortWidget } from \"../../widgets/PortWidget\";\nimport { BaseWidget, BaseWidgetProps } from \"../../widgets/BaseWidget\";\n\nexport interface DefaultPortLabelProps extends BaseWidgetProps {\n\tmodel: DefaultPortModel;\n}\n\nexport interface DefaultPortLabelState {}\n\n/**\n * @author Dylan Vorster\n */\nexport class DefaultPortLabel extends BaseWidget<DefaultPortLabelProps, DefaultPortLabelState> {\n\tconstructor(props) {\n\t\tsuper(\"srd-default-port\", props);\n\t}\n\n\tgetClassName() {\n\t\treturn super.getClassName() + (this.props.model.in ? this.bem(\"--in\") : this.bem(\"--out\"));\n\t}\n\n\trender() {\n\t\tvar port = <PortWidget node={this.props.model.getParent()} name={this.props.model.name} />;\n\t\tvar label = <div className=\"name\">{this.props.model.label}</div>;\n\n\t\treturn (\n\t\t\t<div {...this.getProps()}>\n\t\t\t\t{this.props.model.in ? port : label}\n\t\t\t\t{this.props.model.in ? label : port}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/widgets/DefaultPortLabelWidget.tsx","import * as React from \"react\";\nimport { NodeModel } from \"../models/NodeModel\";\nimport { BaseWidget, BaseWidgetProps } from \"./BaseWidget\";\n\nexport interface PortProps extends BaseWidgetProps {\n\tname: string;\n\tnode: NodeModel;\n}\n\nexport interface PortState {\n\tselected: boolean;\n}\n\n/**\n * @author Dylan Vorster\n */\nexport class PortWidget extends BaseWidget<PortProps, PortState> {\n\tconstructor(props: PortProps) {\n\t\tsuper(\"srd-port\", props);\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\t}\n\n\tgetClassName() {\n\t\treturn \"port \" + super.getClassName() + (this.state.selected ? this.bem(\"--selected\") : \"\");\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div\n\t\t\t\t{...this.getProps()}\n\t\t\t\tonMouseEnter={() => {\n\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t}}\n\t\t\t\tonMouseLeave={() => {\n\t\t\t\t\tthis.setState({ selected: false });\n\t\t\t\t}}\n\t\t\t\tdata-name={this.props.name}\n\t\t\t\tdata-nodeid={this.props.node.getID()}\n\t\t\t/>\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/PortWidget.tsx","import { DefaultPortModel } from \"../models/DefaultPortModel\";\nimport { PortFactory } from \"../../AbstractFactory\";\n\nexport class DefaultPortFactory extends PortFactory<DefaultPortModel> {\n\tconstructor() {\n\t\tsuper(\"default\");\n\t}\n\n\tgetNewInstance(initialConfig?: any): DefaultPortModel {\n\t\treturn new DefaultPortModel(true, \"unknown\");\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/factories/DefaultPortFactory.tsx","import { DiagramModel } from \"./models/DiagramModel\";\nimport { DiagramEngine } from \"./DiagramEngine\";\nimport { SelectionModel } from \"./widgets/DiagramWidget\";\nimport { PointModel } from \"./models/PointModel\";\nimport { NodeModel } from \"./models/NodeModel\";\n\nexport class BaseAction {\n\tmouseX: number;\n\tmouseY: number;\n\tms: number;\n\n\tconstructor(mouseX: number, mouseY: number) {\n\t\tthis.mouseX = mouseX;\n\t\tthis.mouseY = mouseY;\n\t\tthis.ms = new Date().getTime();\n\t}\n}\n\nexport class SelectingAction extends BaseAction {\n\tmouseX2: number;\n\tmouseY2: number;\n\n\tconstructor(mouseX: number, mouseY: number) {\n\t\tsuper(mouseX, mouseY);\n\t\tthis.mouseX2 = mouseX;\n\t\tthis.mouseY2 = mouseY;\n\t}\n\n\tgetBoxDimensions() {\n\t\treturn {\n\t\t\tleft: this.mouseX2 > this.mouseX ? this.mouseX : this.mouseX2,\n\t\t\ttop: this.mouseY2 > this.mouseY ? this.mouseY : this.mouseY2,\n\t\t\twidth: Math.abs(this.mouseX2 - this.mouseX),\n\t\t\theight: Math.abs(this.mouseY2 - this.mouseY),\n\t\t\tright: this.mouseX2 < this.mouseX ? this.mouseX : this.mouseX2,\n\t\t\tbottom: this.mouseY2 < this.mouseY ? this.mouseY : this.mouseY2\n\t\t};\n\t}\n\n\tcontainsElement(x: number, y: number, diagramModel: DiagramModel): boolean {\n\t\tvar z = diagramModel.getZoomLevel() / 100.0;\n\t\tlet dimensions = this.getBoxDimensions();\n\n\t\treturn (\n\t\t\tx * z + diagramModel.getOffsetX() > dimensions.left &&\n\t\t\tx * z + diagramModel.getOffsetX() < dimensions.right &&\n\t\t\ty * z + diagramModel.getOffsetY() > dimensions.top &&\n\t\t\ty * z + diagramModel.getOffsetY() < dimensions.bottom\n\t\t);\n\t}\n}\n\nexport class MoveCanvasAction extends BaseAction {\n\tinitialOffsetX: number;\n\tinitialOffsetY: number;\n\n\tconstructor(mouseX: number, mouseY: number, diagramModel: DiagramModel) {\n\t\tsuper(mouseX, mouseY);\n\t\tthis.initialOffsetX = diagramModel.getOffsetX();\n\t\tthis.initialOffsetY = diagramModel.getOffsetY();\n\t}\n}\n\nexport class MoveItemsAction extends BaseAction {\n\tselectionModels: SelectionModel[];\n\tmoved: boolean;\n\n\tconstructor(mouseX: number, mouseY: number, diagramEngine: DiagramEngine) {\n\t\tsuper(mouseX, mouseY);\n\t\tthis.moved = false;\n\t\tdiagramEngine.enableRepaintEntities(diagramEngine.getDiagramModel().getSelectedItems());\n\t\tvar selectedItems = diagramEngine.getDiagramModel().getSelectedItems();\n\n\t\t//dont allow items which are locked to move\n\t\tselectedItems = selectedItems.filter(item => {\n\t\t\treturn !diagramEngine.isModelLocked(item);\n\t\t});\n\n\t\tthis.selectionModels = selectedItems.map((item: PointModel | NodeModel) => {\n\t\t\treturn {\n\t\t\t\tmodel: item,\n\t\t\t\tinitialX: item.x,\n\t\t\t\tinitialY: item.y\n\t\t\t};\n\t\t});\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/CanvasActions.ts","import * as React from \"react\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\nimport { LinkWidget } from \"../LinkWidget\";\nimport * as _ from \"lodash\";\nimport { PointModel } from \"../../models/PointModel\";\nimport { BaseWidget, BaseWidgetProps } from \"../BaseWidget\";\n\nexport interface LinkLayerProps extends BaseWidgetProps {\n\tdiagramEngine: DiagramEngine;\n\tpointAdded: (point: PointModel, event: MouseEvent) => any;\n}\n\nexport interface LinkLayerState {}\n\n/**\n * @author Dylan Vorster\n */\nexport class LinkLayerWidget extends BaseWidget<LinkLayerProps, LinkLayerState> {\n\tconstructor(props: LinkLayerProps) {\n\t\tsuper(\"srd-link-layer\", props);\n\t\tthis.state = {};\n\t}\n\n\trender() {\n\t\tvar diagramModel = this.props.diagramEngine.getDiagramModel();\n\t\treturn (\n\t\t\t<svg\n\t\t\t\t{...this.getProps()}\n\t\t\t\tstyle={{\n\t\t\t\t\ttransform:\n\t\t\t\t\t\t\"translate(\" +\n\t\t\t\t\t\tdiagramModel.getOffsetX() +\n\t\t\t\t\t\t\"px,\" +\n\t\t\t\t\t\tdiagramModel.getOffsetY() +\n\t\t\t\t\t\t\"px) scale(\" +\n\t\t\t\t\t\tdiagramModel.getZoomLevel() / 100.0 +\n\t\t\t\t\t\t\")\"\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t{//only perform these actions when we have a diagram\n\t\t\t\tthis.props.diagramEngine.canvas &&\n\t\t\t\t\t_.map(diagramModel.getLinks(), link => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tthis.props.diagramEngine.nodesRendered &&\n\t\t\t\t\t\t\t!this.props.diagramEngine.linksThatHaveInitiallyRendered[link.id]\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (link.sourcePort !== null) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tconst portCenter = this.props.diagramEngine.getPortCenter(link.sourcePort);\n\t\t\t\t\t\t\t\t\tlink.points[0].updateLocation(portCenter);\n\n\t\t\t\t\t\t\t\t\tconst portCoords = this.props.diagramEngine.getPortCoords(link.sourcePort);\n\t\t\t\t\t\t\t\t\tlink.sourcePort.updateCoords(portCoords);\n\n\t\t\t\t\t\t\t\t\tthis.props.diagramEngine.linksThatHaveInitiallyRendered[link.id] = true;\n\t\t\t\t\t\t\t\t} catch (ex) {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (link.targetPort !== null) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tconst portCenter = this.props.diagramEngine.getPortCenter(link.targetPort);\n\t\t\t\t\t\t\t\t\t_.last(link.points).updateLocation(portCenter);\n\n\t\t\t\t\t\t\t\t\tconst portCoords = this.props.diagramEngine.getPortCoords(link.targetPort);\n\t\t\t\t\t\t\t\t\tlink.targetPort.updateCoords(portCoords);\n\n\t\t\t\t\t\t\t\t\tthis.props.diagramEngine.linksThatHaveInitiallyRendered[link.id] = true;\n\t\t\t\t\t\t\t\t} catch (ex) {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//generate links\n\t\t\t\t\t\tvar generatedLink = this.props.diagramEngine.generateWidgetForLink(link);\n\t\t\t\t\t\tif (!generatedLink) {\n\t\t\t\t\t\t\tconsole.log(\"no link generated for type: \" + link.getType());\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<LinkWidget key={link.getID()} link={link} diagramEngine={this.props.diagramEngine}>\n\t\t\t\t\t\t\t\t{React.cloneElement(generatedLink, {\n\t\t\t\t\t\t\t\t\tpointAdded: this.props.pointAdded\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</LinkWidget>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t</svg>\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/layers/LinkLayerWidget.tsx","import * as React from \"react\";\nimport { DiagramEngine } from \"../DiagramEngine\";\nimport { LinkModel } from \"../models/LinkModel\";\nimport { BaseWidget, BaseWidgetProps } from \"./BaseWidget\";\n\nexport interface LinkProps extends BaseWidgetProps {\n\tlink: LinkModel;\n\tdiagramEngine: DiagramEngine;\n\tchildren?: any;\n}\n\nexport interface LinkState {}\n\n/**\n * @author Dylan Vorster\n */\nexport class LinkWidget extends BaseWidget<LinkProps, LinkState> {\n\tconstructor(props: LinkProps) {\n\t\tsuper(\"srd-link\", props);\n\t\tthis.state = {};\n\t}\n\n\tshouldComponentUpdate() {\n\t\treturn this.props.diagramEngine.canEntityRepaint(this.props.link);\n\t}\n\n\trender() {\n\t\treturn this.props.children;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/LinkWidget.tsx","import * as React from \"react\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\nimport * as _ from \"lodash\";\nimport { NodeWidget } from \"../NodeWidget\";\nimport { NodeModel } from \"../../models/NodeModel\";\nimport { BaseWidget, BaseWidgetProps } from \"../BaseWidget\";\n\nexport interface NodeLayerProps extends BaseWidgetProps {\n\tdiagramEngine: DiagramEngine;\n}\n\nexport interface NodeLayerState {}\n\nexport class NodeLayerWidget extends BaseWidget<NodeLayerProps, NodeLayerState> {\n\tconstructor(props: NodeLayerProps) {\n\t\tsuper(\"srd-node-layer\", props);\n\t\tthis.state = {};\n\t}\n\n\tupdateNodeDimensions = () => {\n\t\tif (!this.props.diagramEngine.nodesRendered) {\n\t\t\tconst diagramModel = this.props.diagramEngine.getDiagramModel();\n\t\t\t_.map(diagramModel.getNodes(), node => {\n\t\t\t\tnode.updateDimensions(this.props.diagramEngine.getNodeDimensions(node));\n\t\t\t});\n\t\t}\n\t};\n\n\tcomponentDidUpdate() {\n\t\tthis.updateNodeDimensions();\n\t\tthis.props.diagramEngine.nodesRendered = true;\n\t}\n\n\trender() {\n\t\tvar diagramModel = this.props.diagramEngine.getDiagramModel();\n\t\treturn (\n\t\t\t<div\n\t\t\t\t{...this.getProps()}\n\t\t\t\tstyle={{\n\t\t\t\t\ttransform:\n\t\t\t\t\t\t\"translate(\" +\n\t\t\t\t\t\tdiagramModel.getOffsetX() +\n\t\t\t\t\t\t\"px,\" +\n\t\t\t\t\t\tdiagramModel.getOffsetY() +\n\t\t\t\t\t\t\"px) scale(\" +\n\t\t\t\t\t\tdiagramModel.getZoomLevel() / 100.0 +\n\t\t\t\t\t\t\")\"\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t{_.map(diagramModel.getNodes(), (node: NodeModel) => {\n\t\t\t\t\treturn React.createElement(\n\t\t\t\t\t\tNodeWidget,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdiagramEngine: this.props.diagramEngine,\n\t\t\t\t\t\t\tkey: node.id,\n\t\t\t\t\t\t\tnode: node\n\t\t\t\t\t\t},\n\t\t\t\t\t\tthis.props.diagramEngine.generateWidgetForNode(node)\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/layers/NodeLayerWidget.tsx","import * as React from \"react\";\nimport { DiagramEngine } from \"../DiagramEngine\";\nimport { NodeModel } from \"../models/NodeModel\";\nimport { Toolkit } from \"../Toolkit\";\nimport { BaseWidget, BaseWidgetProps } from \"./BaseWidget\";\n\nexport interface NodeProps extends BaseWidgetProps {\n\tnode: NodeModel;\n\tchildren?: any;\n\tdiagramEngine: DiagramEngine;\n}\n\nexport interface NodeState {}\n\n/**\n * @author Dylan Vorster\n */\nexport class NodeWidget extends BaseWidget<NodeProps, NodeState> {\n\tconstructor(props: NodeProps) {\n\t\tsuper(\"srd-node\", props);\n\t\tthis.state = {};\n\t}\n\n\tshouldComponentUpdate() {\n\t\treturn this.props.diagramEngine.canEntityRepaint(this.props.node);\n\t}\n\n\tgetClassName() {\n\t\treturn \"node \" + super.getClassName() + (this.props.node.isSelected() ? this.bem(\"--selected\") : \"\");\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div\n\t\t\t\t{...this.getProps()}\n\t\t\t\tdata-nodeid={this.props.node.id}\n\t\t\t\tstyle={{\n\t\t\t\t\ttop: this.props.node.y,\n\t\t\t\t\tleft: this.props.node.x\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t{this.props.children}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/NodeWidget.tsx","var matches = require('matches-selector')\r\n\r\nmodule.exports = function (element, selector, checkYoSelf) {\r\n  var parent = checkYoSelf ? element : element.parentNode\r\n\r\n  while (parent && parent !== document) {\r\n    if (matches(parent, selector)) return parent;\r\n    parent = parent.parentNode\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/closest/index.js\n// module id = 37\n// module chunks = 0","\r\n/**\r\n * Element prototype.\r\n */\r\n\r\nvar proto = Element.prototype;\r\n\r\n/**\r\n * Vendor function.\r\n */\r\n\r\nvar vendor = proto.matchesSelector\r\n  || proto.webkitMatchesSelector\r\n  || proto.mozMatchesSelector\r\n  || proto.msMatchesSelector\r\n  || proto.oMatchesSelector;\r\n\r\n/**\r\n * Expose `match()`.\r\n */\r\n\r\nmodule.exports = match;\r\n\r\n/**\r\n * Match `el` to `selector`.\r\n *\r\n * @param {Element} el\r\n * @param {String} selector\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nfunction match(el, selector) {\r\n  if (vendor) return vendor.call(el, selector);\r\n  var nodes = el.parentNode.querySelectorAll(selector);\r\n  for (var i = 0; i < nodes.length; ++i) {\r\n    if (nodes[i] == el) return true;\r\n  }\r\n  return false;\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/matches-selector/index.js\n// module id = 38\n// module chunks = 0","module.exports = require('./src/PathFinding');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/index.js\n// module id = 39\n// module chunks = 0","module.exports = {\r\n    'Heap'                      : require('heap'),\r\n    'Node'                      : require('./core/Node'),\r\n    'Grid'                      : require('./core/Grid'),\r\n    'Util'                      : require('./core/Util'),\r\n    'DiagonalMovement'          : require('./core/DiagonalMovement'),\r\n    'Heuristic'                 : require('./core/Heuristic'),\r\n    'AStarFinder'               : require('./finders/AStarFinder'),\r\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\r\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\r\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\r\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\r\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\r\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\r\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\r\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\r\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/PathFinding.js\n// module id = 40\n// module chunks = 0","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/heap/lib/heap.js\n// module id = 41\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 42\n// module chunks = 0","var Node = require('./Node');\r\nvar DiagonalMovement = require('./DiagonalMovement');\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // \r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // \r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // \r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // \r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // \r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/core/Grid.js\n// module id = 43\n// module chunks = 0","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/BestFirstFinder.js\n// module id = 44\n// module chunks = 0","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/BreadthFirstFinder.js\n// module id = 45\n// module chunks = 0","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/DijkstraFinder.js\n// module id = 46\n// module chunks = 0","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/BiBestFirstFinder.js\n// module id = 47\n// module chunks = 0","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js\n// module id = 48\n// module chunks = 0","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/BiDijkstraFinder.js\n// module id = 49\n// module chunks = 0","var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/IDAStarFinder.js\n// module id = 50\n// module chunks = 0","/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\r\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\r\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/JumpPointFinder.js\n// module id = 51\n// module chunks = 0","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js\n// module id = 52\n// module chunks = 0","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js\n// module id = 53\n// module chunks = 0","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js\n// module id = 54\n// module chunks = 0","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js\n// module id = 55\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nvar Path = function Path(init) {\n  var _instructions = init || [];\n\n  var push = function push(arr, el) {\n    var copy = arr.slice(0, arr.length);\n    copy.push(el);\n    return copy;\n  };\n\n  var areEqualPoints = function areEqualPoints(_ref, _ref3) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    var a1 = _ref2[0];\n    var b1 = _ref2[1];\n\n    var _ref32 = _slicedToArray(_ref3, 2);\n\n    var a2 = _ref32[0];\n    var b2 = _ref32[1];\n    return a1 === a2 && b1 === b2;\n  };\n\n  var trimZeros = function trimZeros(string, char) {\n    var l = string.length;\n    while (string.charAt(l - 1) === '0') {\n      l = l - 1;\n    }\n    if (string.charAt(l - 1) === '.') {\n      l = l - 1;\n    }\n    return string.substr(0, l);\n  };\n\n  var round = function round(number, digits) {\n    var str = number.toFixed(digits);\n    return trimZeros(str);\n  };\n\n  var printInstrunction = function printInstrunction(_ref4) {\n    var command = _ref4.command;\n    var params = _ref4.params;\n\n    var numbers = params.map(function (param) {\n      return round(param, 6);\n    });\n    return command + ' ' + numbers.join(' ');\n  };\n\n  var point = function point(_ref5, _ref6) {\n    var command = _ref5.command;\n    var params = _ref5.params;\n\n    var _ref62 = _slicedToArray(_ref6, 2);\n\n    var prevX = _ref62[0];\n    var prevY = _ref62[1];\n\n    switch (command) {\n      case 'M':\n        return [params[0], params[1]];\n      case 'L':\n        return [params[0], params[1]];\n      case 'H':\n        return [params[0], prevY];\n      case 'V':\n        return [prevX, params[0]];\n      case 'Z':\n        return null;\n      case 'C':\n        return [params[4], params[5]];\n      case 'S':\n        return [params[2], params[3]];\n      case 'Q':\n        return [params[2], params[3]];\n      case 'T':\n        return [params[0], params[1]];\n      case 'A':\n        return [params[5], params[6]];\n    }\n  };\n\n  var verbosify = function verbosify(keys, f) {\n    return function (a) {\n      var args = typeof a === 'object' ? keys.map(function (k) {\n        return a[k];\n      }) : arguments;\n      return f.apply(null, args);\n    };\n  };\n\n  var plus = function plus(instruction) {\n    return Path(push(_instructions, instruction));\n  };\n\n  return {\n    moveto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'M',\n        params: [x, y]\n      });\n    }),\n    lineto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'L',\n        params: [x, y]\n      });\n    }),\n    hlineto: verbosify(['x'], function (x) {\n      return plus({\n        command: 'H',\n        params: [x]\n      });\n    }),\n    vlineto: verbosify(['y'], function (y) {\n      return plus({\n        command: 'V',\n        params: [y]\n      });\n    }),\n    closepath: function closepath() {\n      return plus({\n        command: 'Z',\n        params: []\n      });\n    },\n    curveto: verbosify(['x1', 'y1', 'x2', 'y2', 'x', 'y'], function (x1, y1, x2, y2, x, y) {\n      return plus({\n        command: 'C',\n        params: [x1, y1, x2, y2, x, y]\n      });\n    }),\n    smoothcurveto: verbosify(['x2', 'y2', 'x', 'y'], function (x2, y2, x, y) {\n      return plus({\n        command: 'S',\n        params: [x2, y2, x, y]\n      });\n    }),\n    qcurveto: verbosify(['x1', 'y1', 'x', 'y'], function (x1, y1, x, y) {\n      return plus({\n        command: 'Q',\n        params: [x1, y1, x, y]\n      });\n    }),\n    smoothqcurveto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'T',\n        params: [x, y]\n      });\n    }),\n    arc: verbosify(['rx', 'ry', 'xrot', 'largeArcFlag', 'sweepFlag', 'x', 'y'], function (rx, ry, xrot, largeArcFlag, sweepFlag, x, y) {\n      return plus({\n        command: 'A',\n        params: [rx, ry, xrot, largeArcFlag, sweepFlag, x, y]\n      });\n    }),\n    print: function print() {\n      return _instructions.map(printInstrunction).join(' ');\n    },\n    toString: function toString() {\n      return undefined.print();\n    },\n    points: function points() {\n      var ps = [];\n      var prev = [0, 0];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _instructions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var instruction = _step.value;\n\n          var p = point(instruction, prev);\n          prev = p;\n          if (p) {\n            ps.push(p);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return ps;\n    },\n    instructions: function instructions() {\n      return _instructions.slice(0, _instructions.length);\n    },\n    connect: function connect(path) {\n      var ps = this.points();\n      var last = ps[ps.length - 1];\n      var first = path.points()[0];\n      var newInstructions = path.instructions().slice(1);\n      if (!areEqualPoints(last, first)) {\n        newInstructions.unshift({\n          command: \"L\",\n          params: first\n        });\n      }\n      return Path(this.instructions().concat(newInstructions));\n    }\n  };\n};\n\nexports['default'] = function () {\n  return Path();\n};\n\nmodule.exports = exports['default'];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/paths-js/path.js\n// module id = 56\n// module chunks = 0","import * as React from \"react\";\nimport { DefaultLinkWidget } from \"../widgets/DefaultLinkWidget\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\nimport { LinkFactory } from \"../../AbstractFactory\";\nimport { DefaultLinkModel } from \"../models/DefaultLinkModel\";\n\n/**\n * @author Dylan Vorster\n */\nexport class DefaultLinkFactory extends LinkFactory<DefaultLinkModel> {\n\tconstructor() {\n\t\tsuper(\"default\");\n\t}\n\n\tgenerateReactWidget(diagramEngine: DiagramEngine, link: DefaultLinkModel): JSX.Element {\n\t\treturn React.createElement(DefaultLinkWidget, {\n\t\t\tlink: link,\n\t\t\tdiagramEngine: diagramEngine\n\t\t});\n\t}\n\n\tgetNewInstance(initialConfig?: any): DefaultLinkModel {\n\t\treturn new DefaultLinkModel();\n\t}\n\n\tgenerateLinkSegment(model: DefaultLinkModel, widget: DefaultLinkWidget, selected: boolean, path: string) {\n\t\treturn (\n\t\t\t<path\n\t\t\t\tclassName={selected ? widget.bem(\"--path-selected\") : \"\"}\n\t\t\t\tstrokeWidth={model.width}\n\t\t\t\tstroke={model.color}\n\t\t\t\td={path}\n\t\t\t/>\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/factories/DefaultLinkFactory.tsx","import { DefaultNodeModel } from \"../models/DefaultNodeModel\";\nimport * as React from \"react\";\nimport { DefaultNodeWidget } from \"../widgets/DefaultNodeWidget\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\nimport { NodeFactory } from \"../../AbstractFactory\";\n/**\n * @author Dylan Vorster\n */\nexport class DefaultNodeFactory extends NodeFactory<DefaultNodeModel> {\n\tconstructor() {\n\t\tsuper(\"default\");\n\t}\n\n\tgenerateReactWidget(diagramEngine: DiagramEngine, node: DefaultNodeModel): JSX.Element {\n\t\treturn React.createElement(DefaultNodeWidget, {\n\t\t\tnode: node,\n\t\t\tdiagramEngine: diagramEngine\n\t\t});\n\t}\n\n\tgetNewInstance(initialConfig?: any): DefaultNodeModel {\n\t\treturn new DefaultNodeModel();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/factories/DefaultNodeFactory.ts","import { BaseEntity, BaseListener } from \"./BaseEntity\";\nimport { DiagramModel } from \"./models/DiagramModel\";\nimport * as _ from \"lodash\";\nimport { BaseModel, BaseModelListener } from \"./models/BaseModel\";\nimport { NodeModel } from \"./models/NodeModel\";\nimport { PointModel } from \"./models/PointModel\";\nimport { PortModel } from \"./models/PortModel\";\nimport { LinkModel } from \"./models/LinkModel\";\nimport { LabelFactory, LinkFactory, NodeFactory, PortFactory } from \"./AbstractFactory\";\nimport { DefaultLinkFactory, DefaultNodeFactory } from \"./main\";\nimport { ROUTING_SCALING_FACTOR } from \"./routing/PathFinding\";\nimport { DefaultPortFactory } from \"./defaults/factories/DefaultPortFactory\";\nimport { LabelModel } from \"./models/LabelModel\";\nimport { DefaultLabelFactory } from \"./defaults/factories/DefaultLabelFactory\";\nimport { Toolkit } from \"./Toolkit\";\n/**\n * @author Dylan Vorster\n */\nexport interface DiagramEngineListener extends BaseListener {\n\tportFactoriesUpdated?(): void;\n\n\tnodeFactoriesUpdated?(): void;\n\n\tlinkFactoriesUpdated?(): void;\n\n\tlabelFactoriesUpdated?(): void;\n\n\trepaintCanvas?(): void;\n}\n\n/**\n * Passed as a parameter to the DiagramWidget\n */\nexport class DiagramEngine extends BaseEntity<DiagramEngineListener> {\n\tnodeFactories: { [s: string]: NodeFactory };\n\tlinkFactories: { [s: string]: LinkFactory };\n\tportFactories: { [s: string]: PortFactory };\n\tlabelFactories: { [s: string]: LabelFactory };\n\n\tdiagramModel: DiagramModel;\n\tcanvas: Element;\n\tpaintableWidgets: {};\n\tlinksThatHaveInitiallyRendered: {};\n\tnodesRendered: boolean;\n\tmaxNumberPointsPerLink: number;\n\tsmartRouting: boolean;\n\n\t// calculated only when smart routing is active\n\tcanvasMatrix: number[][] = [];\n\troutingMatrix: number[][] = [];\n\t// used when at least one element has negative coordinates\n\thAdjustmentFactor: number = 0;\n\tvAdjustmentFactor: number = 0;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.diagramModel = new DiagramModel();\n\t\tthis.nodeFactories = {};\n\t\tthis.linkFactories = {};\n\t\tthis.portFactories = {};\n\t\tthis.labelFactories = {};\n\t\tthis.canvas = null;\n\t\tthis.paintableWidgets = null;\n\t\tthis.linksThatHaveInitiallyRendered = {};\n\n\t\tif (Toolkit.TESTING) {\n\t\t\tToolkit.TESTING_UID = 0;\n\n\t\t\t//pop it onto the window so our E2E helpers can find it\n\t\t\tif (window) {\n\t\t\t\t(window as any)[\"diagram_instance\"] = this;\n\t\t\t}\n\t\t}\n\t}\n\n\tinstallDefaultFactories() {\n\t\tthis.registerNodeFactory(new DefaultNodeFactory());\n\t\tthis.registerLinkFactory(new DefaultLinkFactory());\n\t\tthis.registerPortFactory(new DefaultPortFactory());\n\t\tthis.registerLabelFactory(new DefaultLabelFactory());\n\t}\n\n\trepaintCanvas() {\n\t\tthis.iterateListeners(listener => {\n\t\t\tlistener.repaintCanvas && listener.repaintCanvas();\n\t\t});\n\t}\n\n\tclearRepaintEntities() {\n\t\tthis.paintableWidgets = null;\n\t}\n\n\tenableRepaintEntities(entities: BaseModel<BaseEntity, BaseModelListener>[]) {\n\t\tthis.paintableWidgets = {};\n\t\tentities.forEach(entity => {\n\t\t\t//if a node is requested to repaint, add all of its links\n\t\t\tif (entity instanceof NodeModel) {\n\t\t\t\t_.forEach(entity.getPorts(), port => {\n\t\t\t\t\t_.forEach(port.getLinks(), link => {\n\t\t\t\t\t\tthis.paintableWidgets[link.getID()] = true;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (entity instanceof PointModel) {\n\t\t\t\tthis.paintableWidgets[entity.getLink().getID()] = true;\n\t\t\t}\n\n\t\t\tthis.paintableWidgets[entity.getID()] = true;\n\t\t});\n\t}\n\n\t/**\n\t * Checks to see if a model is locked by running through\n\t * its parents to see if they are locked first\n\t */\n\tisModelLocked(model: BaseEntity<BaseListener>) {\n\t\t//always check the diagram model\n\t\tif (this.diagramModel.isLocked()) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn model.isLocked();\n\t}\n\n\trecalculatePortsVisually() {\n\t\tthis.nodesRendered = false;\n\t\tthis.linksThatHaveInitiallyRendered = {};\n\t}\n\n\tcanEntityRepaint(baseModel: BaseModel<BaseEntity, BaseModelListener>) {\n\t\t//no rules applied, allow repaint\n\t\tif (this.paintableWidgets === null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn this.paintableWidgets[baseModel.getID()] !== undefined;\n\t}\n\n\tsetCanvas(canvas: Element | null) {\n\t\tthis.canvas = canvas;\n\t}\n\n\tsetDiagramModel(model: DiagramModel) {\n\t\tthis.diagramModel = model;\n\t\tthis.recalculatePortsVisually();\n\t}\n\n\tgetDiagramModel(): DiagramModel {\n\t\treturn this.diagramModel;\n\t}\n\n\t//!-------------- FACTORIES ------------\n\n\tgetNodeFactories(): { [s: string]: NodeFactory } {\n\t\treturn this.nodeFactories;\n\t}\n\n\tgetLinkFactories(): { [s: string]: LinkFactory } {\n\t\treturn this.linkFactories;\n\t}\n\n\tgetLabelFactories(): { [s: string]: LabelFactory } {\n\t\treturn this.labelFactories;\n\t}\n\n\tregisterLabelFactory(factory: LabelFactory) {\n\t\tthis.labelFactories[factory.getType()] = factory;\n\t\tthis.iterateListeners(listener => {\n\t\t\tif (listener.labelFactoriesUpdated) {\n\t\t\t\tlistener.labelFactoriesUpdated();\n\t\t\t}\n\t\t});\n\t}\n\n\tregisterPortFactory(factory: PortFactory) {\n\t\tthis.portFactories[factory.getType()] = factory;\n\t\tthis.iterateListeners(listener => {\n\t\t\tif (listener.portFactoriesUpdated) {\n\t\t\t\tlistener.portFactoriesUpdated();\n\t\t\t}\n\t\t});\n\t}\n\n\tregisterNodeFactory(factory: NodeFactory) {\n\t\tthis.nodeFactories[factory.getType()] = factory;\n\t\tthis.iterateListeners(listener => {\n\t\t\tif (listener.nodeFactoriesUpdated) {\n\t\t\t\tlistener.nodeFactoriesUpdated();\n\t\t\t}\n\t\t});\n\t}\n\n\tregisterLinkFactory(factory: LinkFactory) {\n\t\tthis.linkFactories[factory.getType()] = factory;\n\t\tthis.iterateListeners(listener => {\n\t\t\tif (listener.linkFactoriesUpdated) {\n\t\t\t\tlistener.linkFactoriesUpdated();\n\t\t\t}\n\t\t});\n\t}\n\n\tgetPortFactory(type: string): PortFactory {\n\t\tif (this.portFactories[type]) {\n\t\t\treturn this.portFactories[type];\n\t\t}\n\t\tconsole.log(\"cannot find factory for port of type: [\" + type + \"]\");\n\t\treturn null;\n\t}\n\n\tgetNodeFactory(type: string): NodeFactory {\n\t\tif (this.nodeFactories[type]) {\n\t\t\treturn this.nodeFactories[type];\n\t\t}\n\t\tconsole.log(\"cannot find factory for node of type: [\" + type + \"]\");\n\t\treturn null;\n\t}\n\n\tgetLinkFactory(type: string): LinkFactory {\n\t\tif (this.linkFactories[type]) {\n\t\t\treturn this.linkFactories[type];\n\t\t}\n\t\tconsole.log(\"cannot find factory for link of type: [\" + type + \"]\");\n\t\treturn null;\n\t}\n\n\tgetLabelFactory(type: string): LabelFactory {\n\t\tif (this.labelFactories[type]) {\n\t\t\treturn this.labelFactories[type];\n\t\t}\n\t\tconsole.log(\"cannot find factory for label of type: [\" + type + \"]\");\n\t\treturn null;\n\t}\n\n\tgetFactoryForNode(node: NodeModel): NodeFactory | null {\n\t\treturn this.getNodeFactory(node.getType());\n\t}\n\n\tgetFactoryForLink(link: LinkModel): LinkFactory | null {\n\t\treturn this.getLinkFactory(link.getType());\n\t}\n\n\tgetFactoryForLabel(label: LabelModel): LabelFactory | null {\n\t\treturn this.getLabelFactory(label.getType());\n\t}\n\n\tgenerateWidgetForLink(link: LinkModel): JSX.Element | null {\n\t\tvar linkFactory = this.getFactoryForLink(link);\n\t\tif (!linkFactory) {\n\t\t\tthrow new Error(\"Cannot find link factory for link: \" + link.getType());\n\t\t}\n\t\treturn linkFactory.generateReactWidget(this, link);\n\t}\n\n\tgenerateWidgetForNode(node: NodeModel): JSX.Element | null {\n\t\tvar nodeFactory = this.getFactoryForNode(node);\n\t\tif (!nodeFactory) {\n\t\t\tthrow new Error(\"Cannot find widget factory for node: \" + node.getType());\n\t\t}\n\t\treturn nodeFactory.generateReactWidget(this, node);\n\t}\n\n\tgetRelativeMousePoint(event): { x: number; y: number } {\n\t\tvar point = this.getRelativePoint(event.clientX, event.clientY);\n\t\treturn {\n\t\t\tx: (point.x - this.diagramModel.getOffsetX()) / (this.diagramModel.getZoomLevel() / 100.0),\n\t\t\ty: (point.y - this.diagramModel.getOffsetY()) / (this.diagramModel.getZoomLevel() / 100.0)\n\t\t};\n\t}\n\n\tgetRelativePoint(x, y) {\n\t\tvar canvasRect = this.canvas.getBoundingClientRect();\n\t\treturn { x: x - canvasRect.left, y: y - canvasRect.top };\n\t}\n\n\tgetNodeElement(node: NodeModel): Element {\n\t\tconst selector = this.canvas.querySelector('.node[data-nodeid=\"' + node.getID() + '\"]');\n\t\tif (selector === null) {\n\t\t\tthrow new Error(\"Cannot find Node element with nodeID: [\" + node.getID() + \"]\");\n\t\t}\n\t\treturn selector;\n\t}\n\n\tgetNodePortElement(port: PortModel): any {\n\t\tvar selector = this.canvas.querySelector(\n\t\t\t'.port[data-name=\"' + port.getName() + '\"][data-nodeid=\"' + port.getParent().getID() + '\"]'\n\t\t);\n\t\tif (selector === null) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Cannot find Node Port element with nodeID: [\" +\n\t\t\t\t\tport.getParent().getID() +\n\t\t\t\t\t\"] and name: [\" +\n\t\t\t\t\tport.getName() +\n\t\t\t\t\t\"]\"\n\t\t\t);\n\t\t}\n\t\treturn selector;\n\t}\n\n\tgetPortCenter(port: PortModel) {\n\t\tvar sourceElement = this.getNodePortElement(port);\n\t\tvar sourceRect = sourceElement.getBoundingClientRect();\n\n\t\tvar rel = this.getRelativePoint(sourceRect.left, sourceRect.top);\n\n\t\treturn {\n\t\t\tx:\n\t\t\t\tsourceElement.offsetWidth / 2 +\n\t\t\t\t(rel.x - this.diagramModel.getOffsetX()) / (this.diagramModel.getZoomLevel() / 100.0),\n\t\t\ty:\n\t\t\t\tsourceElement.offsetHeight / 2 +\n\t\t\t\t(rel.y - this.diagramModel.getOffsetY()) / (this.diagramModel.getZoomLevel() / 100.0)\n\t\t};\n\t}\n\n\t/**\n\t * Calculate rectangular coordinates of the port passed in.\n\t */\n\tgetPortCoords(\n\t\tport: PortModel\n\t): {\n\t\tx: number;\n\t\ty: number;\n\t\twidth: number;\n\t\theight: number;\n\t} {\n\t\tconst sourceElement = this.getNodePortElement(port);\n\t\tconst sourceRect = sourceElement.getBoundingClientRect();\n\t\tconst canvasRect = this.canvas.getBoundingClientRect() as ClientRect;\n\n\t\treturn {\n\t\t\tx:\n\t\t\t\t(sourceRect.x - this.diagramModel.getOffsetX()) / (this.diagramModel.getZoomLevel() / 100.0) -\n\t\t\t\tcanvasRect.left,\n\t\t\ty:\n\t\t\t\t(sourceRect.y - this.diagramModel.getOffsetY()) / (this.diagramModel.getZoomLevel() / 100.0) -\n\t\t\t\tcanvasRect.top,\n\t\t\twidth: sourceRect.width,\n\t\t\theight: sourceRect.height\n\t\t};\n\t}\n\n\t/**\n\t * Determine the width and height of the node passed in.\n\t * It currently assumes nodes have a rectangular shape, can be overriden for customised shapes.\n\t */\n\tgetNodeDimensions(node: NodeModel): { width: number; height: number } {\n\t\tif (!this.canvas) {\n\t\t\treturn {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t}\n\n\t\tconst nodeElement = this.getNodeElement(node);\n\t\tconst nodeRect = nodeElement.getBoundingClientRect();\n\n\t\treturn {\n\t\t\twidth: nodeRect.width,\n\t\t\theight: nodeRect.height\n\t\t};\n\t}\n\n\tgetMaxNumberPointsPerLink(): number {\n\t\treturn this.maxNumberPointsPerLink;\n\t}\n\n\tsetMaxNumberPointsPerLink(max: number) {\n\t\tthis.maxNumberPointsPerLink = max;\n\t}\n\n\tisSmartRoutingEnabled() {\n\t\treturn !!this.smartRouting;\n\t}\n\tsetSmartRoutingStatus(status: boolean) {\n\t\tthis.smartRouting = status;\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all walkable points are marked by zeros.\n\t * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n\t */\n\tgetCanvasMatrix(): number[][] {\n\t\tif (this.canvasMatrix.length === 0) {\n\t\t\tthis.calculateCanvasMatrix();\n\t\t}\n\n\t\treturn this.canvasMatrix;\n\t}\n\tcalculateCanvasMatrix() {\n\t\tconst {\n\t\t\twidth: canvasWidth,\n\t\t\thAdjustmentFactor,\n\t\t\theight: canvasHeight,\n\t\t\tvAdjustmentFactor\n\t\t} = this.calculateMatrixDimensions();\n\n\t\tthis.hAdjustmentFactor = hAdjustmentFactor;\n\t\tthis.vAdjustmentFactor = vAdjustmentFactor;\n\n\t\tconst matrixWidth = Math.ceil(canvasWidth / ROUTING_SCALING_FACTOR);\n\t\tconst matrixHeight = Math.ceil(canvasHeight / ROUTING_SCALING_FACTOR);\n\n\t\tthis.canvasMatrix = _.range(0, matrixHeight).map(() => {\n\t\t\treturn new Array(matrixWidth).fill(0);\n\t\t});\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 1 1 0 0 0 0 |\n\t * | 0 0 1 1 0 0 1 1 |\n\t * | 0 0 0 0 0 0 1 1 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all points blocked by a node (and its ports) are\n\t * marked as 1; points were there is nothing (ie, free) receive 0.\n\t */\n\tgetRoutingMatrix(): number[][] {\n\t\tif (this.routingMatrix.length === 0) {\n\t\t\tthis.calculateRoutingMatrix();\n\t\t}\n\n\t\treturn this.routingMatrix;\n\t}\n\tcalculateRoutingMatrix(): void {\n\t\tconst matrix = _.cloneDeep(this.getCanvasMatrix());\n\n\t\t// nodes need to be marked as blocked points\n\t\tthis.markNodes(matrix);\n\t\t// same thing for ports\n\t\tthis.markPorts(matrix);\n\n\t\tthis.routingMatrix = matrix;\n\t}\n\n\t/**\n\t * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n\t * We use the functions below to translate back and forth between these coordinates, relying on the\n\t * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n\t */\n\ttranslateRoutingX(x: number, reverse: boolean = false) {\n\t\treturn x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\ttranslateRoutingY(y: number, reverse: boolean = false) {\n\t\treturn y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\n\t/**\n\t * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n\t * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n\t */\n\tcalculateMatrixDimensions = (): {\n\t\twidth: number;\n\t\thAdjustmentFactor: number;\n\t\theight: number;\n\t\tvAdjustmentFactor: number;\n\t} => {\n\t\tconst allNodesCoords = _.values(this.diagramModel.nodes).map(item => ({\n\t\t\tx: item.x,\n\t\t\twidth: item.width,\n\t\t\ty: item.y,\n\t\t\theight: item.height\n\t\t}));\n\n\t\tconst allLinks = _.values(this.diagramModel.links);\n\t\tconst allPortsCoords = _.flatMap(allLinks.map(link => [link.sourcePort, link.targetPort]))\n\t\t\t.filter(port => port !== null)\n\t\t\t.map(item => ({\n\t\t\t\tx: item.x,\n\t\t\t\twidth: item.width,\n\t\t\t\ty: item.y,\n\t\t\t\theight: item.height\n\t\t\t}));\n\t\tconst allPointsCoords = _.flatMap(allLinks.map(link => link.points)).map(item => ({\n\t\t\t// points don't have width/height, so let's just use 0\n\t\t\tx: item.x,\n\t\t\twidth: 0,\n\t\t\ty: item.y,\n\t\t\theight: 0\n\t\t}));\n\n\t\tconst canvas = this.canvas as HTMLDivElement;\n\t\tconst minX =\n\t\t\tMath.floor(\n\t\t\t\tMath.min(_.minBy(_.concat(allNodesCoords, allPortsCoords, allPointsCoords), item => item.x).x, 0) /\n\t\t\t\t\tROUTING_SCALING_FACTOR\n\t\t\t) * ROUTING_SCALING_FACTOR;\n\t\tconst maxXElement = _.maxBy(\n\t\t\t_.concat(allNodesCoords, allPortsCoords, allPointsCoords),\n\t\t\titem => item.x + item.width\n\t\t);\n\t\tconst maxX = Math.max(maxXElement.x + maxXElement.width, canvas.offsetWidth);\n\n\t\tconst minY =\n\t\t\tMath.floor(\n\t\t\t\tMath.min(_.minBy(_.concat(allNodesCoords, allPortsCoords, allPointsCoords), item => item.y).y, 0) /\n\t\t\t\t\tROUTING_SCALING_FACTOR\n\t\t\t) * ROUTING_SCALING_FACTOR;\n\t\tconst maxYElement = _.maxBy(\n\t\t\t_.concat(allNodesCoords, allPortsCoords, allPointsCoords),\n\t\t\titem => item.y + item.height\n\t\t);\n\t\tconst maxY = Math.max(maxYElement.y + maxYElement.height, canvas.offsetHeight);\n\n\t\treturn {\n\t\t\twidth: Math.ceil(Math.abs(minX) + maxX),\n\t\t\thAdjustmentFactor: Math.abs(minX) / ROUTING_SCALING_FACTOR + 1,\n\t\t\theight: Math.ceil(Math.abs(minY) + maxY),\n\t\t\tvAdjustmentFactor: Math.abs(minY) / ROUTING_SCALING_FACTOR + 1\n\t\t};\n\t};\n\n\t/**\n\t * Updates (by reference) where nodes will be drawn on the matrix passed in.\n\t */\n\tmarkNodes = (matrix: number[][]): void => {\n\t\t_.values(this.diagramModel.nodes).forEach(node => {\n\t\t\tconst startX = Math.floor(node.x / ROUTING_SCALING_FACTOR);\n\t\t\tconst endX = Math.ceil((node.x + node.width) / ROUTING_SCALING_FACTOR);\n\t\t\tconst startY = Math.floor(node.y / ROUTING_SCALING_FACTOR);\n\t\t\tconst endY = Math.ceil((node.y + node.height) / ROUTING_SCALING_FACTOR);\n\n\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Updates (by reference) where ports will be drawn on the matrix passed in.\n\t */\n\tmarkPorts = (matrix: number[][]): void => {\n\t\tconst allElements = _.flatMap(\n\t\t\t_.values(this.diagramModel.links).map(link => [].concat(link.sourcePort, link.targetPort))\n\t\t);\n\t\tallElements.filter(port => port !== null).forEach(port => {\n\t\t\tconst startX = Math.floor(port.x / ROUTING_SCALING_FACTOR);\n\t\t\tconst endX = Math.ceil((port.x + port.width) / ROUTING_SCALING_FACTOR);\n\t\t\tconst startY = Math.floor(port.y / ROUTING_SCALING_FACTOR);\n\t\t\tconst endY = Math.ceil((port.y + port.height) / ROUTING_SCALING_FACTOR);\n\n\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tmarkMatrixPoint = (matrix: number[][], x: number, y: number) => {\n\t\tif (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n\t\t\tmatrix[y][x] = 1;\n\t\t}\n\t};\n\n\tzoomToFit() {\n\t\tconst xFactor = this.canvas.clientWidth / this.canvas.scrollWidth;\n\t\tconst yFactor = this.canvas.clientHeight / this.canvas.scrollHeight;\n\t\tconst zoomFactor = xFactor < yFactor ? xFactor : yFactor;\n\n\t\tthis.diagramModel.setZoomLevel(this.diagramModel.getZoomLevel() * zoomFactor);\n\t\tthis.diagramModel.setOffset(0, 0);\n\t\tthis.repaintCanvas();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/DiagramEngine.ts","import * as React from \"react\";\nimport { DiagramEngine } from \"../../DiagramEngine\";\nimport { LabelFactory } from \"../../AbstractFactory\";\nimport { DefaultLabelModel } from \"../models/DefaultLabelModel\";\nimport { DefaultLabelWidget } from \"../widgets/DefaultLabelWidget\";\n\n/**\n * @author Dylan Vorster\n */\nexport class DefaultLabelFactory extends LabelFactory<DefaultLabelModel> {\n\tconstructor() {\n\t\tsuper(\"default\");\n\t}\n\n\tgenerateReactWidget(diagramEngine: DiagramEngine, label: DefaultLabelModel): JSX.Element {\n\t\treturn <DefaultLabelWidget model={label} />;\n\t}\n\n\tgetNewInstance(initialConfig?: any): DefaultLabelModel {\n\t\treturn new DefaultLabelModel();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/factories/DefaultLabelFactory.tsx","import * as React from \"react\";\nimport { DefaultLabelModel } from \"../models/DefaultLabelModel\";\nimport { BaseWidget, BaseWidgetProps } from \"../../widgets/BaseWidget\";\n\nexport interface DefaultLabelWidgetProps extends BaseWidgetProps {\n\tmodel: DefaultLabelModel;\n}\n\nexport class DefaultLabelWidget extends BaseWidget<DefaultLabelWidgetProps> {\n\tconstructor(props) {\n\t\tsuper(\"srd-default-label\", props);\n\t}\n\n\trender() {\n\t\treturn <div {...this.getProps()}>{this.props.model.label}</div>;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/defaults/widgets/DefaultLabelWidget.tsx","import * as React from \"react\";\nimport { DiagramEngine } from \"../DiagramEngine\";\nimport * as _ from \"lodash\";\nimport { LinkLayerWidget } from \"./layers/LinkLayerWidget\";\nimport { NodeLayerWidget } from \"./layers/NodeLayerWidget\";\nimport { Toolkit } from \"../Toolkit\";\nimport { BaseAction, MoveCanvasAction, MoveItemsAction, SelectingAction } from \"../CanvasActions\";\nimport { NodeModel } from \"../models/NodeModel\";\nimport { PointModel } from \"../models/PointModel\";\nimport { PortModel } from \"../models/PortModel\";\nimport { LinkModel } from \"../models/LinkModel\";\nimport { BaseModel, BaseModelListener } from \"../models/BaseModel\";\nimport { BaseEntity } from \"../BaseEntity\";\nimport { BaseWidget, BaseWidgetProps } from \"./BaseWidget\";\n\nexport interface SelectionModel {\n\tmodel: BaseModel<BaseEntity, BaseModelListener>;\n\tinitialX: number;\n\tinitialY: number;\n}\n\nexport interface DiagramProps extends BaseWidgetProps {\n\tdiagramEngine: DiagramEngine;\n\n\tallowLooseLinks?: boolean;\n\tallowCanvasTranslation?: boolean;\n\tallowCanvasZoom?: boolean;\n\tinverseZoom?: boolean;\n\tmaxNumberPointsPerLink?: number;\n\tsmartRouting?: boolean;\n\n\tactionStartedFiring?: (action: BaseAction) => boolean;\n\tactionStillFiring?: (action: BaseAction) => void;\n\tactionStoppedFiring?: (action: BaseAction) => void;\n\n\tdeleteKeys?: number[];\n}\n\nexport interface DiagramState {\n\taction: BaseAction | null;\n\twasMoved: boolean;\n\trenderedNodes: boolean;\n\twindowListener: any;\n\tdiagramEngineListener: any;\n\tdocument: any;\n}\n\n/**\n * @author Dylan Vorster\n */\nexport class DiagramWidget extends BaseWidget<DiagramProps, DiagramState> {\n\tpublic static defaultProps: DiagramProps = {\n\t\tdiagramEngine: null,\n\t\tallowLooseLinks: true,\n\t\tallowCanvasTranslation: true,\n\t\tallowCanvasZoom: true,\n\t\tinverseZoom: false,\n\t\tmaxNumberPointsPerLink: Infinity, // backwards compatible default\n\t\tsmartRouting: false,\n\t\tdeleteKeys: [46, 8]\n\t};\n\n\tconstructor(props: DiagramProps) {\n\t\tsuper(\"srd-diagram\", props);\n\t\tthis.onMouseMove = this.onMouseMove.bind(this);\n\t\tthis.onMouseUp = this.onMouseUp.bind(this);\n\t\tthis.state = {\n\t\t\taction: null,\n\t\t\twasMoved: false,\n\t\t\trenderedNodes: false,\n\t\t\twindowListener: null,\n\t\t\tdiagramEngineListener: null,\n\t\t\tdocument: null\n\t\t};\n\t}\n\n\tonKeyUpPointer: null;\n\n\tcomponentWillUnmount() {\n\t\tthis.props.diagramEngine.removeListener(this.state.diagramEngineListener);\n\t\tthis.props.diagramEngine.setCanvas(null);\n\t\twindow.removeEventListener(\"keyup\", this.onKeyUpPointer);\n\t\twindow.removeEventListener(\"mouseUp\", this.onMouseUp);\n\t\twindow.removeEventListener(\"mouseMove\", this.onMouseMove);\n\t}\n\n\tcomponentWillReceiveProps(nextProps: DiagramProps) {\n\t\tif (this.props.diagramEngine !== nextProps.diagramEngine) {\n\t\t\tthis.props.diagramEngine.removeListener(this.state.diagramEngineListener);\n\t\t\tconst diagramEngineListener = nextProps.diagramEngine.addListener({\n\t\t\t\trepaintCanvas: () => this.forceUpdate()\n\t\t\t});\n\t\t\tthis.setState({ diagramEngineListener });\n\t\t}\n\t}\n\n\tcomponentWillUpdate(nextProps: DiagramProps) {\n\t\tif (this.props.diagramEngine.diagramModel.id !== nextProps.diagramEngine.diagramModel.id) {\n\t\t\tthis.setState({ renderedNodes: false });\n\t\t\tnextProps.diagramEngine.diagramModel.rendered = true;\n\t\t}\n\t\tif (!nextProps.diagramEngine.diagramModel.rendered) {\n\t\t\tthis.setState({ renderedNodes: false });\n\t\t\tnextProps.diagramEngine.diagramModel.rendered = true;\n\t\t}\n\t}\n\n\tcomponentDidUpdate() {\n\t\tif (!this.state.renderedNodes) {\n\t\t\tthis.setState({\n\t\t\t\trenderedNodes: true\n\t\t\t});\n\t\t}\n\t}\n\n\tcomponentDidMount() {\n\t\tthis.onKeyUpPointer = this.onKeyUp.bind(this);\n\n\t\t//add a keyboard listener\n\t\tthis.setState({\n\t\t\tdocument: document,\n\t\t\trenderedNodes: true,\n\t\t\tdiagramEngineListener: this.props.diagramEngine.addListener({\n\t\t\t\trepaintCanvas: () => {\n\t\t\t\t\tthis.forceUpdate();\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\n\t\twindow.addEventListener(\"keyup\", this.onKeyUpPointer, false);\n\n\t\t// dont focus the window when in test mode - jsdom fails\n\t\tif (process.env.NODE_ENV !== \"test\") {\n\t\t\twindow.focus();\n\t\t}\n\t}\n\n\t/**\n\t * Gets a model and element under the mouse cursor\n\t */\n\tgetMouseElement(event): { model: BaseModel<BaseEntity, BaseModelListener>; element: Element } {\n\t\tvar target = event.target as Element;\n\t\tvar diagramModel = this.props.diagramEngine.diagramModel;\n\n\t\t//is it a port\n\t\tvar element = Toolkit.closest(target, \".port[data-name]\");\n\t\tif (element) {\n\t\t\tvar nodeElement = Toolkit.closest(target, \".node[data-nodeid]\") as HTMLElement;\n\t\t\treturn {\n\t\t\t\tmodel: diagramModel\n\t\t\t\t\t.getNode(nodeElement.getAttribute(\"data-nodeid\"))\n\t\t\t\t\t.getPort(element.getAttribute(\"data-name\")),\n\t\t\t\telement: element\n\t\t\t};\n\t\t}\n\n\t\t//look for a point\n\t\telement = Toolkit.closest(target, \".point[data-id]\");\n\t\tif (element) {\n\t\t\treturn {\n\t\t\t\tmodel: diagramModel\n\t\t\t\t\t.getLink(element.getAttribute(\"data-linkid\"))\n\t\t\t\t\t.getPointModel(element.getAttribute(\"data-id\")),\n\t\t\t\telement: element\n\t\t\t};\n\t\t}\n\n\t\t//look for a link\n\t\telement = Toolkit.closest(target, \"[data-linkid]\");\n\t\tif (element) {\n\t\t\treturn {\n\t\t\t\tmodel: diagramModel.getLink(element.getAttribute(\"data-linkid\")),\n\t\t\t\telement: element\n\t\t\t};\n\t\t}\n\n\t\t//look for a node\n\t\telement = Toolkit.closest(target, \".node[data-nodeid]\");\n\t\tif (element) {\n\t\t\treturn {\n\t\t\t\tmodel: diagramModel.getNode(element.getAttribute(\"data-nodeid\")),\n\t\t\t\telement: element\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfireAction() {\n\t\tif (this.state.action && this.props.actionStillFiring) {\n\t\t\tthis.props.actionStillFiring(this.state.action);\n\t\t}\n\t}\n\n\tstopFiringAction(shouldSkipEvent?: boolean) {\n\t\tif (this.props.actionStoppedFiring && !shouldSkipEvent) {\n\t\t\tthis.props.actionStoppedFiring(this.state.action);\n\t\t}\n\t\tthis.setState({ action: null });\n\t}\n\n\tstartFiringAction(action: BaseAction) {\n\t\tvar setState = true;\n\t\tif (this.props.actionStartedFiring) {\n\t\t\tsetState = this.props.actionStartedFiring(action);\n\t\t}\n\t\tif (setState) {\n\t\t\tthis.setState({ action: action });\n\t\t}\n\t}\n\n\tonMouseMove(event) {\n\t\tvar diagramEngine = this.props.diagramEngine;\n\t\tvar diagramModel = diagramEngine.getDiagramModel();\n\t\t//select items so draw a bounding box\n\t\tif (this.state.action instanceof SelectingAction) {\n\t\t\tvar relative = diagramEngine.getRelativePoint(event.clientX, event.clientY);\n\n\t\t\t_.forEach(diagramModel.getNodes(), node => {\n\t\t\t\tif ((this.state.action as SelectingAction).containsElement(node.x, node.y, diagramModel)) {\n\t\t\t\t\tnode.setSelected(true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t_.forEach(diagramModel.getLinks(), link => {\n\t\t\t\tvar allSelected = true;\n\t\t\t\t_.forEach(link.points, point => {\n\t\t\t\t\tif ((this.state.action as SelectingAction).containsElement(point.x, point.y, diagramModel)) {\n\t\t\t\t\t\tpoint.setSelected(true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallSelected = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (allSelected) {\n\t\t\t\t\tlink.setSelected(true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.state.action.mouseX2 = relative.x;\n\t\t\tthis.state.action.mouseY2 = relative.y;\n\n\t\t\tthis.fireAction();\n\t\t\tthis.setState({ action: this.state.action });\n\t\t\treturn;\n\t\t} else if (this.state.action instanceof MoveItemsAction) {\n\t\t\tlet amountX = event.clientX - this.state.action.mouseX;\n\t\t\tlet amountY = event.clientY - this.state.action.mouseY;\n\t\t\tlet amountZoom = diagramModel.getZoomLevel() / 100;\n\n\t\t\t_.forEach(this.state.action.selectionModels, model => {\n\t\t\t\t// in this case we need to also work out the relative grid position\n\t\t\t\tif (\n\t\t\t\t\tmodel.model instanceof NodeModel ||\n\t\t\t\t\t(model.model instanceof PointModel && !model.model.isConnectedToPort())\n\t\t\t\t) {\n\t\t\t\t\tmodel.model.x = diagramModel.getGridPosition(model.initialX + amountX / amountZoom);\n\t\t\t\t\tmodel.model.y = diagramModel.getGridPosition(model.initialY + amountY / amountZoom);\n\n\t\t\t\t\t// update port coordinates as well\n\t\t\t\t\tif (model.model instanceof NodeModel) {\n\t\t\t\t\t\t_.forEach(model.model.getPorts(), port => {\n\t\t\t\t\t\t\tconst portCoords = this.props.diagramEngine.getPortCoords(port);\n\t\t\t\t\t\t\tport.updateCoords(portCoords);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (diagramEngine.isSmartRoutingEnabled()) {\n\t\t\t\t\t\tdiagramEngine.calculateRoutingMatrix();\n\t\t\t\t\t}\n\t\t\t\t} else if (model.model instanceof PointModel) {\n\t\t\t\t\t// we want points that are connected to ports, to not neccesarilly snap to grid\n\t\t\t\t\t// this stuff needs to be pixel perfect, dont touch it\n\t\t\t\t\tmodel.model.x = model.initialX + diagramModel.getGridPosition(amountX / amountZoom);\n\t\t\t\t\tmodel.model.y = model.initialY + diagramModel.getGridPosition(amountY / amountZoom);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (diagramEngine.isSmartRoutingEnabled()) {\n\t\t\t\tdiagramEngine.calculateCanvasMatrix();\n\t\t\t}\n\n\t\t\tthis.fireAction();\n\t\t\tif (!this.state.wasMoved) {\n\t\t\t\tthis.setState({ wasMoved: true });\n\t\t\t} else {\n\t\t\t\tthis.forceUpdate();\n\t\t\t}\n\t\t} else if (this.state.action instanceof MoveCanvasAction) {\n\t\t\t//translate the actual canvas\n\t\t\tif (this.props.allowCanvasTranslation) {\n\t\t\t\tdiagramModel.setOffset(\n\t\t\t\t\tthis.state.action.initialOffsetX + (event.clientX - this.state.action.mouseX),\n\t\t\t\t\tthis.state.action.initialOffsetY + (event.clientY - this.state.action.mouseY)\n\t\t\t\t);\n\t\t\t\tthis.fireAction();\n\t\t\t\tthis.forceUpdate();\n\t\t\t}\n\t\t}\n\t}\n\n\tonKeyUp(event) {\n\t\t//delete all selected\n\t\tif (this.props.deleteKeys.indexOf(event.keyCode) !== -1) {\n\t\t\t_.forEach(this.props.diagramEngine.getDiagramModel().getSelectedItems(), element => {\n\t\t\t\t//only delete items which are not locked\n\t\t\t\tif (!this.props.diagramEngine.isModelLocked(element)) {\n\t\t\t\t\telement.remove();\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.forceUpdate();\n\t\t}\n\t}\n\n\tonMouseUp(event) {\n\t\tvar diagramEngine = this.props.diagramEngine;\n\t\t//are we going to connect a link to something?\n\t\tif (this.state.action instanceof MoveItemsAction) {\n\t\t\tvar element = this.getMouseElement(event);\n\t\t\tvar linkConnected = false;\n\t\t\t_.forEach(this.state.action.selectionModels, model => {\n\t\t\t\t//only care about points connecting to things\n\t\t\t\tif (!(model.model instanceof PointModel)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (element && element.model instanceof PortModel && !diagramEngine.isModelLocked(element.model)) {\n\t\t\t\t\tlinkConnected = true;\n\t\t\t\t\tlet link = model.model.getLink();\n\t\t\t\t\tif (link.getTargetPort() !== null) {\n\t\t\t\t\t\t//if this was a valid link already and we are adding a node in the middle, create 2 links from the original\n\t\t\t\t\t\tif (link.getTargetPort() !== element.model && link.getSourcePort() !== element.model) {\n\t\t\t\t\t\t\tconst targetPort = link.getTargetPort();\n\t\t\t\t\t\t\tlet newLink = link.clone({});\n\t\t\t\t\t\t\tnewLink.setSourcePort(element.model);\n\t\t\t\t\t\t\tnewLink.setTargetPort(targetPort);\n\t\t\t\t\t\t\tlink.setTargetPort(element.model);\n\t\t\t\t\t\t\ttargetPort.removeLink(link);\n\t\t\t\t\t\t\tnewLink.removePointsBefore(newLink.getPoints()[link.getPointIndex(model.model)]);\n\t\t\t\t\t\t\tlink.removePointsAfter(model.model);\n\t\t\t\t\t\t\tdiagramEngine.getDiagramModel().addLink(newLink);\n\t\t\t\t\t\t\t//if we are connecting to the same target or source, remove tweener points\n\t\t\t\t\t\t} else if (link.getTargetPort() === element.model) {\n\t\t\t\t\t\t\tlink.removePointsAfter(model.model);\n\t\t\t\t\t\t} else if (link.getSourcePort() === element.model) {\n\t\t\t\t\t\t\tlink.removePointsBefore(model.model);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlink.setTargetPort(element.model);\n\t\t\t\t\t}\n\t\t\t\t\tdelete this.props.diagramEngine.linksThatHaveInitiallyRendered[link.getID()];\n\t\t\t\t}\n\t\t\t\t//if we moved a NodeModel and allowLooseLinks is false, we know that any links involved were valid\n\t\t\t\tif ((!this.props.allowLooseLinks && element.model instanceof NodeModel) || !this.state.wasMoved) {\n\t\t\t\t\tlinkConnected = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t//do we want to allow loose links on the diagram model or not\n\t\t\tif (!linkConnected && !this.props.allowLooseLinks) {\n\t\t\t\t_.forEach(this.state.action.selectionModels, model => {\n\t\t\t\t\t//only care about points connecting to things\n\t\t\t\t\tif (!(model.model instanceof PointModel)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar link = model.model.getLink();\n\t\t\t\t\tif (link.isLastPoint(model.model)) {\n\t\t\t\t\t\tlink.remove();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t//remove any invalid links\n\t\t\t_.forEach(this.state.action.selectionModels, model => {\n\t\t\t\t//only care about points connecting to things\n\t\t\t\tif (!(model.model instanceof PointModel)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar link = model.model.getLink();\n\t\t\t\tvar sourcePort: PortModel = link.getSourcePort();\n\t\t\t\tvar targetPort: PortModel = link.getTargetPort();\n\t\t\t\tif (sourcePort !== null && targetPort !== null) {\n\t\t\t\t\tif (!sourcePort.canLinkToPort(targetPort)) {\n\t\t\t\t\t\t//link not allowed\n\t\t\t\t\t\tlink.remove();\n\t\t\t\t\t} else if (\n\t\t\t\t\t\t_.some(\n\t\t\t\t\t\t\t_.values(targetPort.getLinks()),\n\t\t\t\t\t\t\t(l: LinkModel) =>\n\t\t\t\t\t\t\t\tl !== link && (l.getSourcePort() === sourcePort || l.getTargetPort() === sourcePort)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\t//link is a duplicate\n\t\t\t\t\t\tlink.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tdiagramEngine.clearRepaintEntities();\n\t\t\tthis.stopFiringAction(!this.state.wasMoved);\n\t\t} else {\n\t\t\tdiagramEngine.clearRepaintEntities();\n\t\t\tthis.stopFiringAction();\n\t\t}\n\t\tthis.state.document.removeEventListener(\"mousemove\", this.onMouseMove);\n\t\tthis.state.document.removeEventListener(\"mouseup\", this.onMouseUp);\n\t}\n\n\tdrawSelectionBox() {\n\t\tlet dimensions = (this.state.action as SelectingAction).getBoxDimensions();\n\t\treturn (\n\t\t\t<div\n\t\t\t\tclassName={this.bem(\"__selector\")}\n\t\t\t\tstyle={{\n\t\t\t\t\ttop: dimensions.top,\n\t\t\t\t\tleft: dimensions.left,\n\t\t\t\t\twidth: dimensions.width,\n\t\t\t\t\theight: dimensions.height\n\t\t\t\t}}\n\t\t\t/>\n\t\t);\n\t}\n\n\trender() {\n\t\tvar diagramEngine = this.props.diagramEngine;\n\t\tdiagramEngine.setMaxNumberPointsPerLink(this.props.maxNumberPointsPerLink);\n\t\tdiagramEngine.setSmartRoutingStatus(this.props.smartRouting);\n\t\tvar diagramModel = diagramEngine.getDiagramModel();\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\t{...this.getProps()}\n\t\t\t\tref={ref => {\n\t\t\t\t\tif (ref) {\n\t\t\t\t\t\tthis.props.diagramEngine.setCanvas(ref);\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t\tonWheel={event => {\n\t\t\t\t\tif (this.props.allowCanvasZoom) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\tconst oldZoomFactor = diagramModel.getZoomLevel() / 100;\n\t\t\t\t\t\tlet scrollDelta = this.props.inverseZoom ? -event.deltaY : event.deltaY;\n\t\t\t\t\t\t//check if it is pinch gesture\n\t\t\t\t\t\tif (event.ctrlKey && scrollDelta % 1 !== 0) {\n\t\t\t\t\t\t\t/*Chrome and Firefox sends wheel event with deltaY that\n\t\t\t\t\t\t\t\thave fractional part, also `ctrlKey` prop of the event is true\n\t\t\t\t\t\t\t\tthough ctrl isn't pressed\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tscrollDelta /= 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscrollDelta /= 60;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (diagramModel.getZoomLevel() + scrollDelta > 10) {\n\t\t\t\t\t\t\tdiagramModel.setZoomLevel(diagramModel.getZoomLevel() + scrollDelta);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst zoomFactor = diagramModel.getZoomLevel() / 100;\n\n\t\t\t\t\t\tconst boundingRect = event.currentTarget.getBoundingClientRect();\n\t\t\t\t\t\tconst clientWidth = boundingRect.width;\n\t\t\t\t\t\tconst clientHeight = boundingRect.height;\n\t\t\t\t\t\t// compute difference between rect before and after scroll\n\t\t\t\t\t\tconst widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n\t\t\t\t\t\tconst heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n\t\t\t\t\t\t// compute mouse coords relative to canvas\n\t\t\t\t\t\tconst clientX = event.clientX - boundingRect.left;\n\t\t\t\t\t\tconst clientY = event.clientY - boundingRect.top;\n\n\t\t\t\t\t\t// compute width and height increment factor\n\t\t\t\t\t\tconst xFactor = (clientX - diagramModel.getOffsetX()) / oldZoomFactor / clientWidth;\n\t\t\t\t\t\tconst yFactor = (clientY - diagramModel.getOffsetY()) / oldZoomFactor / clientHeight;\n\n\t\t\t\t\t\tdiagramModel.setOffset(\n\t\t\t\t\t\t\tdiagramModel.getOffsetX() - widthDiff * xFactor,\n\t\t\t\t\t\t\tdiagramModel.getOffsetY() - heightDiff * yFactor\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiagramEngine.enableRepaintEntities([]);\n\t\t\t\t\t\tthis.forceUpdate();\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t\tonMouseDown={event => {\n\t\t\t\t\tthis.setState({ ...this.state, wasMoved: false });\n\n\t\t\t\t\tdiagramEngine.clearRepaintEntities();\n\t\t\t\t\tvar model = this.getMouseElement(event);\n\t\t\t\t\t//the canvas was selected\n\t\t\t\t\tif (model === null) {\n\t\t\t\t\t\t//is it a multiple selection\n\t\t\t\t\t\tif (event.shiftKey) {\n\t\t\t\t\t\t\tvar relative = diagramEngine.getRelativePoint(event.clientX, event.clientY);\n\t\t\t\t\t\t\tthis.startFiringAction(new SelectingAction(relative.x, relative.y));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//its a drag the canvas event\n\t\t\t\t\t\t\tdiagramModel.clearSelection();\n\t\t\t\t\t\t\tthis.startFiringAction(new MoveCanvasAction(event.clientX, event.clientY, diagramModel));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (model.model instanceof PortModel) {\n\t\t\t\t\t\t//its a port element, we want to drag a link\n\t\t\t\t\t\tif (!this.props.diagramEngine.isModelLocked(model.model)) {\n\t\t\t\t\t\t\tvar relative = diagramEngine.getRelativeMousePoint(event);\n\t\t\t\t\t\t\tvar sourcePort = model.model;\n\t\t\t\t\t\t\tvar link = sourcePort.createLinkModel();\n\t\t\t\t\t\t\tlink.setSourcePort(sourcePort);\n\n\t\t\t\t\t\t\tif (link) {\n\t\t\t\t\t\t\t\tlink.removeMiddlePoints();\n\t\t\t\t\t\t\t\tif (link.getSourcePort() !== sourcePort) {\n\t\t\t\t\t\t\t\t\tlink.setSourcePort(sourcePort);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlink.setTargetPort(null);\n\n\t\t\t\t\t\t\t\tlink.getFirstPoint().updateLocation(relative);\n\t\t\t\t\t\t\t\tlink.getLastPoint().updateLocation(relative);\n\n\t\t\t\t\t\t\t\tdiagramModel.clearSelection();\n\t\t\t\t\t\t\t\tlink.getLastPoint().setSelected(true);\n\t\t\t\t\t\t\t\tdiagramModel.addLink(link);\n\n\t\t\t\t\t\t\t\tthis.startFiringAction(\n\t\t\t\t\t\t\t\t\tnew MoveItemsAction(event.clientX, event.clientY, diagramEngine)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdiagramModel.clearSelection();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//its some or other element, probably want to move it\n\t\t\t\t\t\tif (!event.shiftKey && !model.model.isSelected()) {\n\t\t\t\t\t\t\tdiagramModel.clearSelection();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodel.model.setSelected(true);\n\n\t\t\t\t\t\tthis.startFiringAction(new MoveItemsAction(event.clientX, event.clientY, diagramEngine));\n\t\t\t\t\t}\n\t\t\t\t\tthis.state.document.addEventListener(\"mousemove\", this.onMouseMove);\n\t\t\t\t\tthis.state.document.addEventListener(\"mouseup\", this.onMouseUp);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t{this.state.renderedNodes && (\n\t\t\t\t\t<LinkLayerWidget\n\t\t\t\t\t\tdiagramEngine={diagramEngine}\n\t\t\t\t\t\tpointAdded={(point: PointModel, event) => {\n\t\t\t\t\t\t\tthis.state.document.addEventListener(\"mousemove\", this.onMouseMove);\n\t\t\t\t\t\t\tthis.state.document.addEventListener(\"mouseup\", this.onMouseUp);\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\tdiagramModel.clearSelection(point);\n\t\t\t\t\t\t\tthis.setState({\n\t\t\t\t\t\t\t\taction: new MoveItemsAction(event.clientX, event.clientY, diagramEngine)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t<NodeLayerWidget diagramEngine={diagramEngine} />\n\t\t\t\t{this.state.action instanceof SelectingAction && this.drawSelectionBox()}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/DiagramWidget.tsx"],"sourceRoot":""}